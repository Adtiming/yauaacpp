
// Generated from UserAgent.g4 by ANTLR 4.12.0


#include "UserAgentListener.h"
#include "UserAgentVisitor.h"

#include "UserAgentParser.h"


using namespace antlrcpp;
using namespace ycpp;

using namespace antlr4;

namespace {

struct UserAgentParserStaticData final {
  UserAgentParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  UserAgentParserStaticData(const UserAgentParserStaticData&) = delete;
  UserAgentParserStaticData(UserAgentParserStaticData&&) = delete;
  UserAgentParserStaticData& operator=(const UserAgentParserStaticData&) = delete;
  UserAgentParserStaticData& operator=(UserAgentParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag useragentParserOnceFlag;
UserAgentParserStaticData *useragentParserStaticData = nullptr;

void useragentParserInitialize() {
  assert(useragentParserStaticData == nullptr);
  auto staticData = std::make_unique<UserAgentParserStaticData>(
    std::vector<std::string>{
      "userAgent", "rootElements", "rootText", "product", "commentProduct", 
      "productVersionWords", "productName", "productNameWords", "productVersion", 
      "productVersionWithCommas", "productVersionSingleWord", "singleVersion", 
      "singleVersionWithCommas", "productNameVersion", "productNameEmail", 
      "productNameUrl", "productNameUuid", "uuId", "emailAddress", "siteUrl", 
      "base64", "commentSeparator", "commentBlock", "commentEntry", "productNameKeyValue", 
      "productNameNoVersion", "keyValueProductVersionName", "keyValue", 
      "keyWithoutValue", "keyValueVersionName", "keyName", "emptyWord", 
      "multipleWords", "versionWords"
    },
    std::vector<std::string>{
      "", "'\\'", "'\\\"'", "'\"'", "'\\\\'", "'''", "'\\t'", "'application/json'", 
      "'*/*'", "", "", "", "", "'{'", "'}'", "'('", "')'", "'['", "']'", 
      "';'", "':'", "','", "'/'", "'='", "'-'", "'+'", "", "", "", "", "", 
      "'@'"
    },
    std::vector<std::string>{
      "", "", "QUOTE1", "QUOTE2", "QUOTE3", "QUOTE4", "BAD_ESC_TAB", "MIME_TYPE_1", 
      "MIME_TYPE_2", "SPACE", "USERAGENT1", "USERAGENT2", "EMAIL", "CURLYBRACEOPEN", 
      "CURLYBRACECLOSE", "BRACEOPEN", "BRACECLOSE", "BLOCKOPEN", "BLOCKCLOSE", 
      "SEMICOLON", "COLON", "COMMA", "SLASH", "EQUALS", "MINUS", "PLUS", 
      "UUID", "URL", "SPECIALVERSIONWORDS", "UNASSIGNEDVARIABLE", "GIBBERISH", 
      "ATSIGN", "VERSION", "WORD", "BASE64"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,34,944,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,
  	7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,
  	14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,
  	21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,
  	28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,1,0,5,0,70,8,0,10,
  	0,12,0,73,9,0,1,0,3,0,76,8,0,1,0,1,0,3,0,80,8,0,5,0,82,8,0,10,0,12,0,
  	85,9,0,1,0,5,0,88,8,0,10,0,12,0,91,9,0,1,1,1,1,1,1,1,1,1,1,3,1,98,8,1,
  	1,2,1,2,4,2,102,8,2,11,2,12,2,103,1,2,1,2,3,2,108,8,2,1,3,1,3,4,3,112,
  	8,3,11,3,12,3,113,1,3,3,3,117,8,3,1,3,4,3,120,8,3,11,3,12,3,121,1,3,1,
  	3,3,3,126,8,3,1,3,3,3,129,8,3,1,3,1,3,3,3,133,8,3,1,3,3,3,136,8,3,5,3,
  	138,8,3,10,3,12,3,141,9,3,1,3,3,3,144,8,3,1,3,3,3,147,8,3,1,3,1,3,4,3,
  	151,8,3,11,3,12,3,152,1,3,3,3,156,8,3,1,3,1,3,3,3,160,8,3,1,3,3,3,163,
  	8,3,5,3,165,8,3,10,3,12,3,168,9,3,5,3,170,8,3,10,3,12,3,173,9,3,1,3,1,
  	3,3,3,177,8,3,1,3,1,3,3,3,181,8,3,1,3,3,3,184,8,3,1,3,1,3,4,3,188,8,3,
  	11,3,12,3,189,1,3,3,3,193,8,3,1,3,1,3,3,3,197,8,3,1,3,3,3,200,8,3,5,3,
  	202,8,3,10,3,12,3,205,9,3,4,3,207,8,3,11,3,12,3,208,1,3,1,3,3,3,213,8,
  	3,1,3,1,3,3,3,217,8,3,1,3,4,3,220,8,3,11,3,12,3,221,1,3,1,3,3,3,226,8,
  	3,1,3,1,3,5,3,230,8,3,10,3,12,3,233,9,3,1,3,1,3,3,3,237,8,3,5,3,239,8,
  	3,10,3,12,3,242,9,3,1,3,3,3,245,8,3,1,3,3,3,248,8,3,1,3,3,3,251,8,3,4,
  	3,253,8,3,11,3,12,3,254,1,3,1,3,3,3,259,8,3,1,3,1,3,3,3,263,8,3,1,3,4,
  	3,266,8,3,11,3,12,3,267,1,3,1,3,3,3,272,8,3,1,3,3,3,275,8,3,1,3,1,3,3,
  	3,279,8,3,1,3,3,3,282,8,3,4,3,284,8,3,11,3,12,3,285,1,3,3,3,289,8,3,1,
  	3,3,3,292,8,3,1,3,1,3,4,3,296,8,3,11,3,12,3,297,1,3,3,3,301,8,3,1,3,1,
  	3,3,3,305,8,3,1,3,3,3,308,8,3,5,3,310,8,3,10,3,12,3,313,9,3,5,3,315,8,
  	3,10,3,12,3,318,9,3,1,3,1,3,3,3,322,8,3,1,3,1,3,1,3,1,3,3,3,328,8,3,1,
  	4,1,4,4,4,332,8,4,11,4,12,4,333,1,4,4,4,337,8,4,11,4,12,4,338,1,4,3,4,
  	342,8,4,1,4,1,4,3,4,346,8,4,1,4,3,4,349,8,4,5,4,351,8,4,10,4,12,4,354,
  	9,4,1,4,3,4,357,8,4,1,4,3,4,360,8,4,1,4,1,4,4,4,364,8,4,11,4,12,4,365,
  	1,4,3,4,369,8,4,1,4,1,4,3,4,373,8,4,1,4,3,4,376,8,4,5,4,378,8,4,10,4,
  	12,4,381,9,4,5,4,383,8,4,10,4,12,4,386,9,4,1,4,1,4,3,4,390,8,4,1,4,3,
  	4,393,8,4,1,4,1,4,4,4,397,8,4,11,4,12,4,398,1,4,3,4,402,8,4,1,4,1,4,3,
  	4,406,8,4,1,4,3,4,409,8,4,5,4,411,8,4,10,4,12,4,414,9,4,4,4,416,8,4,11,
  	4,12,4,417,1,4,1,4,3,4,422,8,4,1,4,4,4,425,8,4,11,4,12,4,426,1,4,1,4,
  	3,4,431,8,4,1,4,1,4,5,4,435,8,4,10,4,12,4,438,9,4,1,4,1,4,3,4,442,8,4,
  	5,4,444,8,4,10,4,12,4,447,9,4,4,4,449,8,4,11,4,12,4,450,1,4,3,4,454,8,
  	4,1,4,1,4,4,4,458,8,4,11,4,12,4,459,1,4,3,4,463,8,4,1,4,1,4,3,4,467,8,
  	4,1,4,3,4,470,8,4,5,4,472,8,4,10,4,12,4,475,9,4,5,4,477,8,4,10,4,12,4,
  	480,9,4,1,4,1,4,4,4,484,8,4,11,4,12,4,485,1,4,1,4,3,4,490,8,4,1,4,3,4,
  	493,8,4,1,4,1,4,3,4,497,8,4,4,4,499,8,4,11,4,12,4,500,1,4,3,4,504,8,4,
  	1,4,1,4,4,4,508,8,4,11,4,12,4,509,1,4,3,4,513,8,4,1,4,1,4,3,4,517,8,4,
  	1,4,3,4,520,8,4,5,4,522,8,4,10,4,12,4,525,9,4,5,4,527,8,4,10,4,12,4,530,
  	9,4,3,4,532,8,4,1,5,1,5,3,5,536,8,5,1,5,5,5,539,8,5,10,5,12,5,542,9,5,
  	1,5,1,5,3,5,546,8,5,1,6,1,6,1,6,1,6,1,6,1,6,3,6,554,8,6,1,7,1,7,5,7,558,
  	8,7,10,7,12,7,561,9,7,1,7,5,7,564,8,7,10,7,12,7,567,9,7,1,7,1,7,5,7,571,
  	8,7,10,7,12,7,574,9,7,1,7,5,7,577,8,7,10,7,12,7,580,9,7,3,7,582,8,7,1,
  	7,1,7,1,7,5,7,587,8,7,10,7,12,7,590,9,7,1,7,5,7,593,8,7,10,7,12,7,596,
  	9,7,1,7,1,7,1,7,5,7,601,8,7,10,7,12,7,604,9,7,1,7,5,7,607,8,7,10,7,12,
  	7,610,9,7,3,7,612,8,7,3,7,614,8,7,1,8,1,8,1,8,1,8,1,8,1,8,1,8,3,8,623,
  	8,8,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,5,9,636,8,9,10,9,12,9,
  	639,9,9,1,9,1,9,3,9,643,8,9,1,10,1,10,1,10,1,10,3,10,649,8,10,1,11,1,
  	11,1,12,1,12,1,12,5,12,656,8,12,10,12,12,12,659,9,12,1,13,1,13,3,13,663,
  	8,13,1,13,5,13,666,8,13,10,13,12,13,669,9,13,1,14,1,14,1,15,1,15,1,16,
  	1,16,1,17,1,17,1,17,1,17,3,17,681,8,17,1,18,1,18,1,18,1,18,3,18,687,8,
  	18,1,19,1,19,1,19,1,19,3,19,693,8,19,1,20,1,20,1,20,1,20,3,20,699,8,20,
  	1,21,1,21,1,22,1,22,1,22,1,22,1,22,5,22,708,8,22,10,22,12,22,711,9,22,
  	1,22,1,22,1,22,1,22,1,22,1,22,1,22,5,22,720,8,22,10,22,12,22,723,9,22,
  	1,22,1,22,3,22,727,8,22,1,23,1,23,5,23,731,8,23,10,23,12,23,734,9,23,
  	1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,
  	1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,
  	1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,3,23,776,
  	8,23,1,23,5,23,779,8,23,10,23,12,23,782,9,23,4,23,784,8,23,11,23,12,23,
  	785,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,3,23,799,8,
  	23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,3,23,812,8,
  	23,3,23,814,8,23,1,24,1,24,4,24,818,8,24,11,24,12,24,819,1,24,1,24,1,
  	24,1,24,1,24,1,24,3,24,828,8,24,4,24,830,8,24,11,24,12,24,831,1,25,1,
  	25,1,25,1,26,1,26,1,26,5,26,840,8,26,10,26,12,26,843,9,26,1,26,3,26,846,
  	8,26,1,27,1,27,4,27,850,8,27,11,27,12,27,851,1,27,1,27,1,27,1,27,1,27,
  	1,27,1,27,3,27,861,8,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,3,27,
  	871,8,27,3,27,873,8,27,4,27,875,8,27,11,27,12,27,876,1,28,1,28,4,28,881,
  	8,28,11,28,12,28,882,1,29,1,29,1,30,1,30,1,30,5,30,890,8,30,10,30,12,
  	30,893,9,30,1,30,3,30,896,8,30,1,31,1,31,3,31,900,8,31,1,32,5,32,903,
  	8,32,10,32,12,32,906,9,32,1,32,4,32,909,8,32,11,32,12,32,910,1,32,5,32,
  	914,8,32,10,32,12,32,917,9,32,1,32,5,32,920,8,32,10,32,12,32,923,9,32,
  	1,32,1,32,5,32,927,8,32,10,32,12,32,930,9,32,1,32,1,32,3,32,934,8,32,
  	1,33,4,33,937,8,33,11,33,12,33,938,1,33,3,33,942,8,33,1,33,0,0,34,0,2,
  	4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,
  	52,54,56,58,60,62,64,66,0,10,8,0,1,1,3,3,5,5,15,15,17,17,19,19,21,21,
  	23,25,3,0,19,19,21,21,24,24,7,0,1,1,3,3,5,5,16,16,18,19,21,21,23,25,2,
  	0,22,22,31,31,2,0,19,19,24,24,2,0,21,21,24,24,2,0,19,19,21,21,1,1,16,
  	16,1,1,18,18,2,0,20,20,23,23,1145,0,71,1,0,0,0,2,97,1,0,0,0,4,107,1,0,
  	0,0,6,327,1,0,0,0,8,531,1,0,0,0,10,545,1,0,0,0,12,553,1,0,0,0,14,613,
  	1,0,0,0,16,622,1,0,0,0,18,642,1,0,0,0,20,648,1,0,0,0,22,650,1,0,0,0,24,
  	652,1,0,0,0,26,660,1,0,0,0,28,670,1,0,0,0,30,672,1,0,0,0,32,674,1,0,0,
  	0,34,680,1,0,0,0,36,686,1,0,0,0,38,692,1,0,0,0,40,698,1,0,0,0,42,700,
  	1,0,0,0,44,726,1,0,0,0,46,813,1,0,0,0,48,815,1,0,0,0,50,833,1,0,0,0,52,
  	845,1,0,0,0,54,847,1,0,0,0,56,878,1,0,0,0,58,884,1,0,0,0,60,895,1,0,0,
  	0,62,899,1,0,0,0,64,933,1,0,0,0,66,941,1,0,0,0,68,70,7,0,0,0,69,68,1,
  	0,0,0,70,73,1,0,0,0,71,69,1,0,0,0,71,72,1,0,0,0,72,83,1,0,0,0,73,71,1,
  	0,0,0,74,76,7,1,0,0,75,74,1,0,0,0,75,76,1,0,0,0,76,79,1,0,0,0,77,80,3,
  	6,3,0,78,80,3,2,1,0,79,77,1,0,0,0,79,78,1,0,0,0,80,82,1,0,0,0,81,75,1,
  	0,0,0,82,85,1,0,0,0,83,81,1,0,0,0,83,84,1,0,0,0,84,89,1,0,0,0,85,83,1,
  	0,0,0,86,88,7,2,0,0,87,86,1,0,0,0,88,91,1,0,0,0,89,87,1,0,0,0,89,90,1,
  	0,0,0,90,1,1,0,0,0,91,89,1,0,0,0,92,98,3,54,27,0,93,98,3,38,19,0,94,98,
  	3,36,18,0,95,98,3,34,17,0,96,98,3,4,2,0,97,92,1,0,0,0,97,93,1,0,0,0,97,
  	94,1,0,0,0,97,95,1,0,0,0,97,96,1,0,0,0,98,3,1,0,0,0,99,108,5,32,0,0,100,
  	102,5,33,0,0,101,100,1,0,0,0,102,103,1,0,0,0,103,101,1,0,0,0,103,104,
  	1,0,0,0,104,108,1,0,0,0,105,108,5,30,0,0,106,108,5,24,0,0,107,99,1,0,
  	0,0,107,101,1,0,0,0,107,105,1,0,0,0,107,106,1,0,0,0,108,5,1,0,0,0,109,
  	111,3,12,6,0,110,112,3,16,8,0,111,110,1,0,0,0,112,113,1,0,0,0,113,111,
  	1,0,0,0,113,114,1,0,0,0,114,139,1,0,0,0,115,117,5,20,0,0,116,115,1,0,
  	0,0,116,117,1,0,0,0,117,125,1,0,0,0,118,120,5,22,0,0,119,118,1,0,0,0,
  	120,121,1,0,0,0,121,119,1,0,0,0,121,122,1,0,0,0,122,126,1,0,0,0,123,126,
  	5,24,0,0,124,126,5,31,0,0,125,119,1,0,0,0,125,123,1,0,0,0,125,124,1,0,
  	0,0,126,128,1,0,0,0,127,129,5,23,0,0,128,127,1,0,0,0,128,129,1,0,0,0,
  	129,132,1,0,0,0,130,133,3,18,9,0,131,133,3,20,10,0,132,130,1,0,0,0,132,
  	131,1,0,0,0,133,135,1,0,0,0,134,136,5,21,0,0,135,134,1,0,0,0,135,136,
  	1,0,0,0,136,138,1,0,0,0,137,116,1,0,0,0,138,141,1,0,0,0,139,137,1,0,0,
  	0,139,140,1,0,0,0,140,171,1,0,0,0,141,139,1,0,0,0,142,144,7,3,0,0,143,
  	142,1,0,0,0,143,144,1,0,0,0,144,146,1,0,0,0,145,147,7,4,0,0,146,145,1,
  	0,0,0,146,147,1,0,0,0,147,148,1,0,0,0,148,166,3,44,22,0,149,151,7,3,0,
  	0,150,149,1,0,0,0,151,152,1,0,0,0,152,150,1,0,0,0,152,153,1,0,0,0,153,
  	155,1,0,0,0,154,156,5,23,0,0,155,154,1,0,0,0,155,156,1,0,0,0,156,159,
  	1,0,0,0,157,160,3,18,9,0,158,160,3,20,10,0,159,157,1,0,0,0,159,158,1,
  	0,0,0,160,162,1,0,0,0,161,163,5,21,0,0,162,161,1,0,0,0,162,163,1,0,0,
  	0,163,165,1,0,0,0,164,150,1,0,0,0,165,168,1,0,0,0,166,164,1,0,0,0,166,
  	167,1,0,0,0,167,170,1,0,0,0,168,166,1,0,0,0,169,143,1,0,0,0,170,173,1,
  	0,0,0,171,169,1,0,0,0,171,172,1,0,0,0,172,176,1,0,0,0,173,171,1,0,0,0,
  	174,175,5,22,0,0,175,177,5,0,0,1,176,174,1,0,0,0,176,177,1,0,0,0,177,
  	328,1,0,0,0,178,206,3,12,6,0,179,181,7,3,0,0,180,179,1,0,0,0,180,181,
  	1,0,0,0,181,183,1,0,0,0,182,184,7,4,0,0,183,182,1,0,0,0,183,184,1,0,0,
  	0,184,185,1,0,0,0,185,203,3,44,22,0,186,188,7,3,0,0,187,186,1,0,0,0,188,
  	189,1,0,0,0,189,187,1,0,0,0,189,190,1,0,0,0,190,192,1,0,0,0,191,193,5,
  	23,0,0,192,191,1,0,0,0,192,193,1,0,0,0,193,196,1,0,0,0,194,197,3,18,9,
  	0,195,197,3,20,10,0,196,194,1,0,0,0,196,195,1,0,0,0,197,199,1,0,0,0,198,
  	200,5,21,0,0,199,198,1,0,0,0,199,200,1,0,0,0,200,202,1,0,0,0,201,187,
  	1,0,0,0,202,205,1,0,0,0,203,201,1,0,0,0,203,204,1,0,0,0,204,207,1,0,0,
  	0,205,203,1,0,0,0,206,180,1,0,0,0,207,208,1,0,0,0,208,206,1,0,0,0,208,
  	209,1,0,0,0,209,212,1,0,0,0,210,211,5,22,0,0,211,213,5,0,0,1,212,210,
  	1,0,0,0,212,213,1,0,0,0,213,328,1,0,0,0,214,252,3,12,6,0,215,217,5,20,
  	0,0,216,215,1,0,0,0,216,217,1,0,0,0,217,225,1,0,0,0,218,220,5,22,0,0,
  	219,218,1,0,0,0,220,221,1,0,0,0,221,219,1,0,0,0,221,222,1,0,0,0,222,226,
  	1,0,0,0,223,226,5,24,0,0,224,226,5,31,0,0,225,219,1,0,0,0,225,223,1,0,
  	0,0,225,224,1,0,0,0,226,227,1,0,0,0,227,240,3,10,5,0,228,230,7,3,0,0,
  	229,228,1,0,0,0,230,233,1,0,0,0,231,229,1,0,0,0,231,232,1,0,0,0,232,234,
  	1,0,0,0,233,231,1,0,0,0,234,236,3,18,9,0,235,237,5,21,0,0,236,235,1,0,
  	0,0,236,237,1,0,0,0,237,239,1,0,0,0,238,231,1,0,0,0,239,242,1,0,0,0,240,
  	238,1,0,0,0,240,241,1,0,0,0,241,244,1,0,0,0,242,240,1,0,0,0,243,245,7,
  	3,0,0,244,243,1,0,0,0,244,245,1,0,0,0,245,247,1,0,0,0,246,248,7,4,0,0,
  	247,246,1,0,0,0,247,248,1,0,0,0,248,250,1,0,0,0,249,251,3,44,22,0,250,
  	249,1,0,0,0,250,251,1,0,0,0,251,253,1,0,0,0,252,216,1,0,0,0,253,254,1,
  	0,0,0,254,252,1,0,0,0,254,255,1,0,0,0,255,258,1,0,0,0,256,257,5,22,0,
  	0,257,259,5,0,0,1,258,256,1,0,0,0,258,259,1,0,0,0,259,328,1,0,0,0,260,
  	283,3,12,6,0,261,263,5,20,0,0,262,261,1,0,0,0,262,263,1,0,0,0,263,271,
  	1,0,0,0,264,266,5,22,0,0,265,264,1,0,0,0,266,267,1,0,0,0,267,265,1,0,
  	0,0,267,268,1,0,0,0,268,272,1,0,0,0,269,272,5,24,0,0,270,272,5,31,0,0,
  	271,265,1,0,0,0,271,269,1,0,0,0,271,270,1,0,0,0,272,274,1,0,0,0,273,275,
  	5,23,0,0,274,273,1,0,0,0,274,275,1,0,0,0,275,278,1,0,0,0,276,279,3,18,
  	9,0,277,279,3,20,10,0,278,276,1,0,0,0,278,277,1,0,0,0,279,281,1,0,0,0,
  	280,282,5,21,0,0,281,280,1,0,0,0,281,282,1,0,0,0,282,284,1,0,0,0,283,
  	262,1,0,0,0,284,285,1,0,0,0,285,283,1,0,0,0,285,286,1,0,0,0,286,316,1,
  	0,0,0,287,289,7,3,0,0,288,287,1,0,0,0,288,289,1,0,0,0,289,291,1,0,0,0,
  	290,292,7,4,0,0,291,290,1,0,0,0,291,292,1,0,0,0,292,293,1,0,0,0,293,311,
  	3,44,22,0,294,296,7,3,0,0,295,294,1,0,0,0,296,297,1,0,0,0,297,295,1,0,
  	0,0,297,298,1,0,0,0,298,300,1,0,0,0,299,301,5,23,0,0,300,299,1,0,0,0,
  	300,301,1,0,0,0,301,304,1,0,0,0,302,305,3,18,9,0,303,305,3,20,10,0,304,
  	302,1,0,0,0,304,303,1,0,0,0,305,307,1,0,0,0,306,308,5,21,0,0,307,306,
  	1,0,0,0,307,308,1,0,0,0,308,310,1,0,0,0,309,295,1,0,0,0,310,313,1,0,0,
  	0,311,309,1,0,0,0,311,312,1,0,0,0,312,315,1,0,0,0,313,311,1,0,0,0,314,
  	288,1,0,0,0,315,318,1,0,0,0,316,314,1,0,0,0,316,317,1,0,0,0,317,321,1,
  	0,0,0,318,316,1,0,0,0,319,320,5,22,0,0,320,322,5,0,0,1,321,319,1,0,0,
  	0,321,322,1,0,0,0,322,328,1,0,0,0,323,324,3,12,6,0,324,325,5,22,0,0,325,
  	326,5,0,0,1,326,328,1,0,0,0,327,109,1,0,0,0,327,178,1,0,0,0,327,214,1,
  	0,0,0,327,260,1,0,0,0,327,323,1,0,0,0,328,7,1,0,0,0,329,331,3,12,6,0,
  	330,332,3,18,9,0,331,330,1,0,0,0,332,333,1,0,0,0,333,331,1,0,0,0,333,
  	334,1,0,0,0,334,352,1,0,0,0,335,337,7,3,0,0,336,335,1,0,0,0,337,338,1,
  	0,0,0,338,336,1,0,0,0,338,339,1,0,0,0,339,341,1,0,0,0,340,342,5,23,0,
  	0,341,340,1,0,0,0,341,342,1,0,0,0,342,345,1,0,0,0,343,346,3,18,9,0,344,
  	346,3,20,10,0,345,343,1,0,0,0,345,344,1,0,0,0,346,348,1,0,0,0,347,349,
  	5,21,0,0,348,347,1,0,0,0,348,349,1,0,0,0,349,351,1,0,0,0,350,336,1,0,
  	0,0,351,354,1,0,0,0,352,350,1,0,0,0,352,353,1,0,0,0,353,384,1,0,0,0,354,
  	352,1,0,0,0,355,357,7,3,0,0,356,355,1,0,0,0,356,357,1,0,0,0,357,359,1,
  	0,0,0,358,360,5,24,0,0,359,358,1,0,0,0,359,360,1,0,0,0,360,361,1,0,0,
  	0,361,379,3,44,22,0,362,364,7,3,0,0,363,362,1,0,0,0,364,365,1,0,0,0,365,
  	363,1,0,0,0,365,366,1,0,0,0,366,368,1,0,0,0,367,369,5,23,0,0,368,367,
  	1,0,0,0,368,369,1,0,0,0,369,372,1,0,0,0,370,373,3,18,9,0,371,373,3,20,
  	10,0,372,370,1,0,0,0,372,371,1,0,0,0,373,375,1,0,0,0,374,376,5,21,0,0,
  	375,374,1,0,0,0,375,376,1,0,0,0,376,378,1,0,0,0,377,363,1,0,0,0,378,381,
  	1,0,0,0,379,377,1,0,0,0,379,380,1,0,0,0,380,383,1,0,0,0,381,379,1,0,0,
  	0,382,356,1,0,0,0,383,386,1,0,0,0,384,382,1,0,0,0,384,385,1,0,0,0,385,
  	532,1,0,0,0,386,384,1,0,0,0,387,415,3,12,6,0,388,390,7,3,0,0,389,388,
  	1,0,0,0,389,390,1,0,0,0,390,392,1,0,0,0,391,393,5,24,0,0,392,391,1,0,
  	0,0,392,393,1,0,0,0,393,394,1,0,0,0,394,412,3,44,22,0,395,397,7,3,0,0,
  	396,395,1,0,0,0,397,398,1,0,0,0,398,396,1,0,0,0,398,399,1,0,0,0,399,401,
  	1,0,0,0,400,402,5,23,0,0,401,400,1,0,0,0,401,402,1,0,0,0,402,405,1,0,
  	0,0,403,406,3,18,9,0,404,406,3,20,10,0,405,403,1,0,0,0,405,404,1,0,0,
  	0,406,408,1,0,0,0,407,409,5,21,0,0,408,407,1,0,0,0,408,409,1,0,0,0,409,
  	411,1,0,0,0,410,396,1,0,0,0,411,414,1,0,0,0,412,410,1,0,0,0,412,413,1,
  	0,0,0,413,416,1,0,0,0,414,412,1,0,0,0,415,389,1,0,0,0,416,417,1,0,0,0,
  	417,415,1,0,0,0,417,418,1,0,0,0,418,532,1,0,0,0,419,448,3,12,6,0,420,
  	422,5,20,0,0,421,420,1,0,0,0,421,422,1,0,0,0,422,430,1,0,0,0,423,425,
  	5,22,0,0,424,423,1,0,0,0,425,426,1,0,0,0,426,424,1,0,0,0,426,427,1,0,
  	0,0,427,431,1,0,0,0,428,431,5,24,0,0,429,431,5,31,0,0,430,424,1,0,0,0,
  	430,428,1,0,0,0,430,429,1,0,0,0,431,432,1,0,0,0,432,445,3,10,5,0,433,
  	435,7,3,0,0,434,433,1,0,0,0,435,438,1,0,0,0,436,434,1,0,0,0,436,437,1,
  	0,0,0,437,439,1,0,0,0,438,436,1,0,0,0,439,441,3,18,9,0,440,442,5,21,0,
  	0,441,440,1,0,0,0,441,442,1,0,0,0,442,444,1,0,0,0,443,436,1,0,0,0,444,
  	447,1,0,0,0,445,443,1,0,0,0,445,446,1,0,0,0,446,449,1,0,0,0,447,445,1,
  	0,0,0,448,421,1,0,0,0,449,450,1,0,0,0,450,448,1,0,0,0,450,451,1,0,0,0,
  	451,478,1,0,0,0,452,454,5,24,0,0,453,452,1,0,0,0,453,454,1,0,0,0,454,
  	455,1,0,0,0,455,473,3,44,22,0,456,458,7,3,0,0,457,456,1,0,0,0,458,459,
  	1,0,0,0,459,457,1,0,0,0,459,460,1,0,0,0,460,462,1,0,0,0,461,463,5,23,
  	0,0,462,461,1,0,0,0,462,463,1,0,0,0,463,466,1,0,0,0,464,467,3,18,9,0,
  	465,467,3,20,10,0,466,464,1,0,0,0,466,465,1,0,0,0,467,469,1,0,0,0,468,
  	470,5,21,0,0,469,468,1,0,0,0,469,470,1,0,0,0,470,472,1,0,0,0,471,457,
  	1,0,0,0,472,475,1,0,0,0,473,471,1,0,0,0,473,474,1,0,0,0,474,477,1,0,0,
  	0,475,473,1,0,0,0,476,453,1,0,0,0,477,480,1,0,0,0,478,476,1,0,0,0,478,
  	479,1,0,0,0,479,532,1,0,0,0,480,478,1,0,0,0,481,498,3,12,6,0,482,484,
  	5,22,0,0,483,482,1,0,0,0,484,485,1,0,0,0,485,483,1,0,0,0,485,486,1,0,
  	0,0,486,490,1,0,0,0,487,490,5,24,0,0,488,490,5,31,0,0,489,483,1,0,0,0,
  	489,487,1,0,0,0,489,488,1,0,0,0,490,492,1,0,0,0,491,493,5,23,0,0,492,
  	491,1,0,0,0,492,493,1,0,0,0,493,494,1,0,0,0,494,496,3,18,9,0,495,497,
  	5,21,0,0,496,495,1,0,0,0,496,497,1,0,0,0,497,499,1,0,0,0,498,489,1,0,
  	0,0,499,500,1,0,0,0,500,498,1,0,0,0,500,501,1,0,0,0,501,528,1,0,0,0,502,
  	504,5,24,0,0,503,502,1,0,0,0,503,504,1,0,0,0,504,505,1,0,0,0,505,523,
  	3,44,22,0,506,508,7,3,0,0,507,506,1,0,0,0,508,509,1,0,0,0,509,507,1,0,
  	0,0,509,510,1,0,0,0,510,512,1,0,0,0,511,513,5,23,0,0,512,511,1,0,0,0,
  	512,513,1,0,0,0,513,516,1,0,0,0,514,517,3,18,9,0,515,517,3,20,10,0,516,
  	514,1,0,0,0,516,515,1,0,0,0,517,519,1,0,0,0,518,520,5,21,0,0,519,518,
  	1,0,0,0,519,520,1,0,0,0,520,522,1,0,0,0,521,507,1,0,0,0,522,525,1,0,0,
  	0,523,521,1,0,0,0,523,524,1,0,0,0,524,527,1,0,0,0,525,523,1,0,0,0,526,
  	503,1,0,0,0,527,530,1,0,0,0,528,526,1,0,0,0,528,529,1,0,0,0,529,532,1,
  	0,0,0,530,528,1,0,0,0,531,329,1,0,0,0,531,387,1,0,0,0,531,419,1,0,0,0,
  	531,481,1,0,0,0,532,9,1,0,0,0,533,540,5,33,0,0,534,536,5,24,0,0,535,534,
  	1,0,0,0,535,536,1,0,0,0,536,537,1,0,0,0,537,539,5,33,0,0,538,535,1,0,
  	0,0,539,542,1,0,0,0,540,538,1,0,0,0,540,541,1,0,0,0,541,546,1,0,0,0,542,
  	540,1,0,0,0,543,546,5,29,0,0,544,546,5,28,0,0,545,533,1,0,0,0,545,543,
  	1,0,0,0,545,544,1,0,0,0,546,11,1,0,0,0,547,554,3,48,24,0,548,554,3,28,
  	14,0,549,554,3,30,15,0,550,554,3,26,13,0,551,554,3,32,16,0,552,554,3,
  	14,7,0,553,547,1,0,0,0,553,548,1,0,0,0,553,549,1,0,0,0,553,550,1,0,0,
  	0,553,551,1,0,0,0,553,552,1,0,0,0,554,13,1,0,0,0,555,565,5,33,0,0,556,
  	558,7,5,0,0,557,556,1,0,0,0,558,561,1,0,0,0,559,557,1,0,0,0,559,560,1,
  	0,0,0,560,562,1,0,0,0,561,559,1,0,0,0,562,564,5,33,0,0,563,559,1,0,0,
  	0,564,567,1,0,0,0,565,563,1,0,0,0,565,566,1,0,0,0,566,614,1,0,0,0,567,
  	565,1,0,0,0,568,578,5,33,0,0,569,571,7,5,0,0,570,569,1,0,0,0,571,574,
  	1,0,0,0,572,570,1,0,0,0,572,573,1,0,0,0,573,575,1,0,0,0,574,572,1,0,0,
  	0,575,577,5,33,0,0,576,572,1,0,0,0,577,580,1,0,0,0,578,576,1,0,0,0,578,
  	579,1,0,0,0,579,582,1,0,0,0,580,578,1,0,0,0,581,568,1,0,0,0,581,582,1,
  	0,0,0,582,583,1,0,0,0,583,584,5,13,0,0,584,594,5,33,0,0,585,587,7,5,0,
  	0,586,585,1,0,0,0,587,590,1,0,0,0,588,586,1,0,0,0,588,589,1,0,0,0,589,
  	591,1,0,0,0,590,588,1,0,0,0,591,593,5,33,0,0,592,588,1,0,0,0,593,596,
  	1,0,0,0,594,592,1,0,0,0,594,595,1,0,0,0,595,597,1,0,0,0,596,594,1,0,0,
  	0,597,611,5,14,0,0,598,608,5,33,0,0,599,601,7,5,0,0,600,599,1,0,0,0,601,
  	604,1,0,0,0,602,600,1,0,0,0,602,603,1,0,0,0,603,605,1,0,0,0,604,602,1,
  	0,0,0,605,607,5,33,0,0,606,602,1,0,0,0,607,610,1,0,0,0,608,606,1,0,0,
  	0,608,609,1,0,0,0,609,612,1,0,0,0,610,608,1,0,0,0,611,598,1,0,0,0,611,
  	612,1,0,0,0,612,614,1,0,0,0,613,555,1,0,0,0,613,581,1,0,0,0,614,15,1,
  	0,0,0,615,623,3,54,27,0,616,623,3,36,18,0,617,623,3,38,19,0,618,623,3,
  	34,17,0,619,623,3,40,20,0,620,623,3,22,11,0,621,623,5,28,0,0,622,615,
  	1,0,0,0,622,616,1,0,0,0,622,617,1,0,0,0,622,618,1,0,0,0,622,619,1,0,0,
  	0,622,620,1,0,0,0,622,621,1,0,0,0,623,17,1,0,0,0,624,643,3,54,27,0,625,
  	643,3,36,18,0,626,643,3,38,19,0,627,643,3,34,17,0,628,643,3,40,20,0,629,
  	643,3,24,12,0,630,643,5,28,0,0,631,632,5,13,0,0,632,637,3,54,27,0,633,
  	634,5,21,0,0,634,636,3,54,27,0,635,633,1,0,0,0,636,639,1,0,0,0,637,635,
  	1,0,0,0,637,638,1,0,0,0,638,640,1,0,0,0,639,637,1,0,0,0,640,641,5,14,
  	0,0,641,643,1,0,0,0,642,624,1,0,0,0,642,625,1,0,0,0,642,626,1,0,0,0,642,
  	627,1,0,0,0,642,628,1,0,0,0,642,629,1,0,0,0,642,630,1,0,0,0,642,631,1,
  	0,0,0,643,19,1,0,0,0,644,649,5,33,0,0,645,646,5,13,0,0,646,647,5,33,0,
  	0,647,649,5,14,0,0,648,644,1,0,0,0,648,645,1,0,0,0,649,21,1,0,0,0,650,
  	651,5,32,0,0,651,23,1,0,0,0,652,657,5,32,0,0,653,654,5,21,0,0,654,656,
  	5,32,0,0,655,653,1,0,0,0,656,659,1,0,0,0,657,655,1,0,0,0,657,658,1,0,
  	0,0,658,25,1,0,0,0,659,657,1,0,0,0,660,667,5,32,0,0,661,663,5,24,0,0,
  	662,661,1,0,0,0,662,663,1,0,0,0,663,664,1,0,0,0,664,666,5,33,0,0,665,
  	662,1,0,0,0,666,669,1,0,0,0,667,665,1,0,0,0,667,668,1,0,0,0,668,27,1,
  	0,0,0,669,667,1,0,0,0,670,671,3,36,18,0,671,29,1,0,0,0,672,673,3,38,19,
  	0,673,31,1,0,0,0,674,675,3,34,17,0,675,33,1,0,0,0,676,681,5,26,0,0,677,
  	678,5,13,0,0,678,679,5,26,0,0,679,681,5,14,0,0,680,676,1,0,0,0,680,677,
  	1,0,0,0,681,35,1,0,0,0,682,687,5,12,0,0,683,684,5,13,0,0,684,685,5,12,
  	0,0,685,687,5,14,0,0,686,682,1,0,0,0,686,683,1,0,0,0,687,37,1,0,0,0,688,
  	693,5,27,0,0,689,690,5,13,0,0,690,691,5,27,0,0,691,693,5,14,0,0,692,688,
  	1,0,0,0,692,689,1,0,0,0,693,39,1,0,0,0,694,699,5,34,0,0,695,696,5,13,
  	0,0,696,697,5,34,0,0,697,699,5,14,0,0,698,694,1,0,0,0,698,695,1,0,0,0,
  	699,41,1,0,0,0,700,701,7,6,0,0,701,43,1,0,0,0,702,703,5,15,0,0,703,709,
  	3,46,23,0,704,705,3,42,21,0,705,706,3,46,23,0,706,708,1,0,0,0,707,704,
  	1,0,0,0,708,711,1,0,0,0,709,707,1,0,0,0,709,710,1,0,0,0,710,712,1,0,0,
  	0,711,709,1,0,0,0,712,713,7,7,0,0,713,727,1,0,0,0,714,715,5,17,0,0,715,
  	721,3,46,23,0,716,717,3,42,21,0,717,718,3,46,23,0,718,720,1,0,0,0,719,
  	716,1,0,0,0,720,723,1,0,0,0,721,719,1,0,0,0,721,722,1,0,0,0,722,724,1,
  	0,0,0,723,721,1,0,0,0,724,725,7,8,0,0,725,727,1,0,0,0,726,702,1,0,0,0,
  	726,714,1,0,0,0,727,45,1,0,0,0,728,814,3,62,31,0,729,731,5,29,0,0,730,
  	729,1,0,0,0,731,734,1,0,0,0,732,730,1,0,0,0,732,733,1,0,0,0,733,775,1,
  	0,0,0,734,732,1,0,0,0,735,776,3,8,4,0,736,776,3,54,27,0,737,776,3,34,
  	17,0,738,776,3,38,19,0,739,776,3,36,18,0,740,776,3,66,33,0,741,776,3,
  	40,20,0,742,743,5,13,0,0,743,744,3,8,4,0,744,745,5,14,0,0,745,776,1,0,
  	0,0,746,747,5,13,0,0,747,748,3,54,27,0,748,749,5,14,0,0,749,776,1,0,0,
  	0,750,751,5,13,0,0,751,752,3,34,17,0,752,753,5,14,0,0,753,776,1,0,0,0,
  	754,755,5,13,0,0,755,756,3,38,19,0,756,757,5,14,0,0,757,776,1,0,0,0,758,
  	759,5,13,0,0,759,760,3,36,18,0,760,761,5,14,0,0,761,776,1,0,0,0,762,763,
  	5,13,0,0,763,764,3,64,32,0,764,765,5,14,0,0,765,776,1,0,0,0,766,767,5,
  	13,0,0,767,768,3,66,33,0,768,769,5,14,0,0,769,776,1,0,0,0,770,771,5,13,
  	0,0,771,772,3,40,20,0,772,773,5,14,0,0,773,776,1,0,0,0,774,776,3,44,22,
  	0,775,735,1,0,0,0,775,736,1,0,0,0,775,737,1,0,0,0,775,738,1,0,0,0,775,
  	739,1,0,0,0,775,740,1,0,0,0,775,741,1,0,0,0,775,742,1,0,0,0,775,746,1,
  	0,0,0,775,750,1,0,0,0,775,754,1,0,0,0,775,758,1,0,0,0,775,762,1,0,0,0,
  	775,766,1,0,0,0,775,770,1,0,0,0,775,774,1,0,0,0,776,780,1,0,0,0,777,779,
  	5,24,0,0,778,777,1,0,0,0,779,782,1,0,0,0,780,778,1,0,0,0,780,781,1,0,
  	0,0,781,784,1,0,0,0,782,780,1,0,0,0,783,732,1,0,0,0,784,785,1,0,0,0,785,
  	783,1,0,0,0,785,786,1,0,0,0,786,798,1,0,0,0,787,799,3,64,32,0,788,799,
  	3,50,25,0,789,799,3,56,28,0,790,791,5,13,0,0,791,792,3,50,25,0,792,793,
  	5,14,0,0,793,799,1,0,0,0,794,795,5,13,0,0,795,796,3,56,28,0,796,797,5,
  	14,0,0,797,799,1,0,0,0,798,787,1,0,0,0,798,788,1,0,0,0,798,789,1,0,0,
  	0,798,790,1,0,0,0,798,794,1,0,0,0,798,799,1,0,0,0,799,814,1,0,0,0,800,
  	812,3,64,32,0,801,812,3,50,25,0,802,812,3,56,28,0,803,804,5,13,0,0,804,
  	805,3,50,25,0,805,806,5,14,0,0,806,812,1,0,0,0,807,808,5,13,0,0,808,809,
  	3,56,28,0,809,810,5,14,0,0,810,812,1,0,0,0,811,800,1,0,0,0,811,801,1,
  	0,0,0,811,802,1,0,0,0,811,803,1,0,0,0,811,807,1,0,0,0,812,814,1,0,0,0,
  	813,728,1,0,0,0,813,783,1,0,0,0,813,811,1,0,0,0,814,47,1,0,0,0,815,829,
  	3,60,30,0,816,818,7,9,0,0,817,816,1,0,0,0,818,819,1,0,0,0,819,817,1,0,
  	0,0,819,820,1,0,0,0,820,827,1,0,0,0,821,828,3,34,17,0,822,828,3,38,19,
  	0,823,828,3,36,18,0,824,828,3,64,32,0,825,828,3,40,20,0,826,828,3,52,
  	26,0,827,821,1,0,0,0,827,822,1,0,0,0,827,823,1,0,0,0,827,824,1,0,0,0,
  	827,825,1,0,0,0,827,826,1,0,0,0,828,830,1,0,0,0,829,817,1,0,0,0,830,831,
  	1,0,0,0,831,829,1,0,0,0,831,832,1,0,0,0,832,49,1,0,0,0,833,834,3,12,6,
  	0,834,835,5,22,0,0,835,51,1,0,0,0,836,841,5,32,0,0,837,838,5,22,0,0,838,
  	840,5,33,0,0,839,837,1,0,0,0,840,843,1,0,0,0,841,839,1,0,0,0,841,842,
  	1,0,0,0,842,846,1,0,0,0,843,841,1,0,0,0,844,846,5,32,0,0,845,836,1,0,
  	0,0,845,844,1,0,0,0,846,53,1,0,0,0,847,874,3,60,30,0,848,850,7,9,0,0,
  	849,848,1,0,0,0,850,851,1,0,0,0,851,849,1,0,0,0,851,852,1,0,0,0,852,872,
  	1,0,0,0,853,860,5,13,0,0,854,861,3,34,17,0,855,861,3,38,19,0,856,861,
  	3,36,18,0,857,861,3,64,32,0,858,861,3,40,20,0,859,861,3,58,29,0,860,854,
  	1,0,0,0,860,855,1,0,0,0,860,856,1,0,0,0,860,857,1,0,0,0,860,858,1,0,0,
  	0,860,859,1,0,0,0,861,862,1,0,0,0,862,863,5,14,0,0,863,873,1,0,0,0,864,
  	871,3,34,17,0,865,871,3,38,19,0,866,871,3,36,18,0,867,871,3,64,32,0,868,
  	871,3,40,20,0,869,871,3,58,29,0,870,864,1,0,0,0,870,865,1,0,0,0,870,866,
  	1,0,0,0,870,867,1,0,0,0,870,868,1,0,0,0,870,869,1,0,0,0,871,873,1,0,0,
  	0,872,853,1,0,0,0,872,870,1,0,0,0,873,875,1,0,0,0,874,849,1,0,0,0,875,
  	876,1,0,0,0,876,874,1,0,0,0,876,877,1,0,0,0,877,55,1,0,0,0,878,880,3,
  	60,30,0,879,881,7,9,0,0,880,879,1,0,0,0,881,882,1,0,0,0,882,880,1,0,0,
  	0,882,883,1,0,0,0,883,57,1,0,0,0,884,885,5,32,0,0,885,59,1,0,0,0,886,
  	891,5,33,0,0,887,888,5,24,0,0,888,890,5,33,0,0,889,887,1,0,0,0,890,893,
  	1,0,0,0,891,889,1,0,0,0,891,892,1,0,0,0,892,896,1,0,0,0,893,891,1,0,0,
  	0,894,896,5,32,0,0,895,886,1,0,0,0,895,894,1,0,0,0,896,61,1,0,0,0,897,
  	900,1,0,0,0,898,900,5,24,0,0,899,897,1,0,0,0,899,898,1,0,0,0,900,63,1,
  	0,0,0,901,903,5,24,0,0,902,901,1,0,0,0,903,906,1,0,0,0,904,902,1,0,0,
  	0,904,905,1,0,0,0,905,907,1,0,0,0,906,904,1,0,0,0,907,909,5,33,0,0,908,
  	904,1,0,0,0,909,910,1,0,0,0,910,908,1,0,0,0,910,911,1,0,0,0,911,915,1,
  	0,0,0,912,914,5,24,0,0,913,912,1,0,0,0,914,917,1,0,0,0,915,913,1,0,0,
  	0,915,916,1,0,0,0,916,934,1,0,0,0,917,915,1,0,0,0,918,920,5,33,0,0,919,
  	918,1,0,0,0,920,923,1,0,0,0,921,919,1,0,0,0,921,922,1,0,0,0,922,924,1,
  	0,0,0,923,921,1,0,0,0,924,928,5,30,0,0,925,927,5,33,0,0,926,925,1,0,0,
  	0,927,930,1,0,0,0,928,926,1,0,0,0,928,929,1,0,0,0,929,934,1,0,0,0,930,
  	928,1,0,0,0,931,934,5,24,0,0,932,934,5,29,0,0,933,908,1,0,0,0,933,921,
  	1,0,0,0,933,931,1,0,0,0,933,932,1,0,0,0,934,65,1,0,0,0,935,937,5,32,0,
  	0,936,935,1,0,0,0,937,938,1,0,0,0,938,936,1,0,0,0,938,939,1,0,0,0,939,
  	942,1,0,0,0,940,942,5,28,0,0,941,936,1,0,0,0,941,940,1,0,0,0,942,67,1,
  	0,0,0,169,71,75,79,83,89,97,103,107,113,116,121,125,128,132,135,139,143,
  	146,152,155,159,162,166,171,176,180,183,189,192,196,199,203,208,212,216,
  	221,225,231,236,240,244,247,250,254,258,262,267,271,274,278,281,285,288,
  	291,297,300,304,307,311,316,321,327,333,338,341,345,348,352,356,359,365,
  	368,372,375,379,384,389,392,398,401,405,408,412,417,421,426,430,436,441,
  	445,450,453,459,462,466,469,473,478,485,489,492,496,500,503,509,512,516,
  	519,523,528,531,535,540,545,553,559,565,572,578,581,588,594,602,608,611,
  	613,622,637,642,648,657,662,667,680,686,692,698,709,721,726,732,775,780,
  	785,798,811,813,819,827,831,841,845,851,860,870,872,876,882,891,895,899,
  	904,910,915,921,928,933,938,941
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  useragentParserStaticData = staticData.release();
}

}

UserAgentParser::UserAgentParser(TokenStream *input) : UserAgentParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

UserAgentParser::UserAgentParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  UserAgentParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *useragentParserStaticData->atn, useragentParserStaticData->decisionToDFA, useragentParserStaticData->sharedContextCache, options);
}

UserAgentParser::~UserAgentParser() {
  delete _interpreter;
}

const atn::ATN& UserAgentParser::getATN() const {
  return *useragentParserStaticData->atn;
}

std::string UserAgentParser::getGrammarFileName() const {
  return "UserAgent.g4";
}

const std::vector<std::string>& UserAgentParser::getRuleNames() const {
  return useragentParserStaticData->ruleNames;
}

const dfa::Vocabulary& UserAgentParser::getVocabulary() const {
  return useragentParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView UserAgentParser::getSerializedATN() const {
  return useragentParserStaticData->serializedATN;
}


//----------------- UserAgentContext ------------------------------------------------------------------

UserAgentParser::UserAgentContext::UserAgentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> UserAgentParser::UserAgentContext::SEMICOLON() {
  return getTokens(UserAgentParser::SEMICOLON);
}

tree::TerminalNode* UserAgentParser::UserAgentContext::SEMICOLON(size_t i) {
  return getToken(UserAgentParser::SEMICOLON, i);
}

std::vector<tree::TerminalNode *> UserAgentParser::UserAgentContext::COMMA() {
  return getTokens(UserAgentParser::COMMA);
}

tree::TerminalNode* UserAgentParser::UserAgentContext::COMMA(size_t i) {
  return getToken(UserAgentParser::COMMA, i);
}

std::vector<tree::TerminalNode *> UserAgentParser::UserAgentContext::MINUS() {
  return getTokens(UserAgentParser::MINUS);
}

tree::TerminalNode* UserAgentParser::UserAgentContext::MINUS(size_t i) {
  return getToken(UserAgentParser::MINUS, i);
}

std::vector<tree::TerminalNode *> UserAgentParser::UserAgentContext::PLUS() {
  return getTokens(UserAgentParser::PLUS);
}

tree::TerminalNode* UserAgentParser::UserAgentContext::PLUS(size_t i) {
  return getToken(UserAgentParser::PLUS, i);
}

std::vector<tree::TerminalNode *> UserAgentParser::UserAgentContext::QUOTE4() {
  return getTokens(UserAgentParser::QUOTE4);
}

tree::TerminalNode* UserAgentParser::UserAgentContext::QUOTE4(size_t i) {
  return getToken(UserAgentParser::QUOTE4, i);
}

std::vector<tree::TerminalNode *> UserAgentParser::UserAgentContext::QUOTE2() {
  return getTokens(UserAgentParser::QUOTE2);
}

tree::TerminalNode* UserAgentParser::UserAgentContext::QUOTE2(size_t i) {
  return getToken(UserAgentParser::QUOTE2, i);
}

std::vector<tree::TerminalNode *> UserAgentParser::UserAgentContext::EQUALS() {
  return getTokens(UserAgentParser::EQUALS);
}

tree::TerminalNode* UserAgentParser::UserAgentContext::EQUALS(size_t i) {
  return getToken(UserAgentParser::EQUALS, i);
}

std::vector<tree::TerminalNode *> UserAgentParser::UserAgentContext::BRACEOPEN() {
  return getTokens(UserAgentParser::BRACEOPEN);
}

tree::TerminalNode* UserAgentParser::UserAgentContext::BRACEOPEN(size_t i) {
  return getToken(UserAgentParser::BRACEOPEN, i);
}

std::vector<tree::TerminalNode *> UserAgentParser::UserAgentContext::BLOCKOPEN() {
  return getTokens(UserAgentParser::BLOCKOPEN);
}

tree::TerminalNode* UserAgentParser::UserAgentContext::BLOCKOPEN(size_t i) {
  return getToken(UserAgentParser::BLOCKOPEN, i);
}

std::vector<tree::TerminalNode *> UserAgentParser::UserAgentContext::BRACECLOSE() {
  return getTokens(UserAgentParser::BRACECLOSE);
}

tree::TerminalNode* UserAgentParser::UserAgentContext::BRACECLOSE(size_t i) {
  return getToken(UserAgentParser::BRACECLOSE, i);
}

std::vector<tree::TerminalNode *> UserAgentParser::UserAgentContext::BLOCKCLOSE() {
  return getTokens(UserAgentParser::BLOCKCLOSE);
}

tree::TerminalNode* UserAgentParser::UserAgentContext::BLOCKCLOSE(size_t i) {
  return getToken(UserAgentParser::BLOCKCLOSE, i);
}

std::vector<UserAgentParser::ProductContext *> UserAgentParser::UserAgentContext::product() {
  return getRuleContexts<UserAgentParser::ProductContext>();
}

UserAgentParser::ProductContext* UserAgentParser::UserAgentContext::product(size_t i) {
  return getRuleContext<UserAgentParser::ProductContext>(i);
}

std::vector<UserAgentParser::RootElementsContext *> UserAgentParser::UserAgentContext::rootElements() {
  return getRuleContexts<UserAgentParser::RootElementsContext>();
}

UserAgentParser::RootElementsContext* UserAgentParser::UserAgentContext::rootElements(size_t i) {
  return getRuleContext<UserAgentParser::RootElementsContext>(i);
}


size_t UserAgentParser::UserAgentContext::getRuleIndex() const {
  return UserAgentParser::RuleUserAgent;
}

void UserAgentParser::UserAgentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUserAgent(this);
}

void UserAgentParser::UserAgentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUserAgent(this);
}


std::any UserAgentParser::UserAgentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<UserAgentVisitor*>(visitor))
    return parserVisitor->visitUserAgent(this);
  else
    return visitor->visitChildren(this);
}

UserAgentParser::UserAgentContext* UserAgentParser::userAgent() {
  UserAgentContext *_localctx = _tracker.createInstance<UserAgentContext>(_ctx, getState());
  enterRule(_localctx, 0, UserAgentParser::RuleUserAgent);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(71);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 0, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(68);
        _la = _input->LA(1);
        if (!((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 61505578) != 0))) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        } 
      }
      setState(73);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 0, _ctx);
    }
    setState(83);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(75);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1, _ctx)) {
        case 1: {
          setState(74);
          _la = _input->LA(1);
          if (!((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 19398656) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          break;
        }

        default:
          break;
        }
        setState(79);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 2, _ctx)) {
        case 1: {
          setState(77);
          product();
          break;
        }

        case 2: {
          setState(78);
          rootElements();
          break;
        }

        default:
          break;
        } 
      }
      setState(85);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx);
    }
    setState(89);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 61669418) != 0)) {
      setState(86);
      _la = _input->LA(1);
      if (!((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 61669418) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(91);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RootElementsContext ------------------------------------------------------------------

UserAgentParser::RootElementsContext::RootElementsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

UserAgentParser::KeyValueContext* UserAgentParser::RootElementsContext::keyValue() {
  return getRuleContext<UserAgentParser::KeyValueContext>(0);
}

UserAgentParser::SiteUrlContext* UserAgentParser::RootElementsContext::siteUrl() {
  return getRuleContext<UserAgentParser::SiteUrlContext>(0);
}

UserAgentParser::EmailAddressContext* UserAgentParser::RootElementsContext::emailAddress() {
  return getRuleContext<UserAgentParser::EmailAddressContext>(0);
}

UserAgentParser::UuIdContext* UserAgentParser::RootElementsContext::uuId() {
  return getRuleContext<UserAgentParser::UuIdContext>(0);
}

UserAgentParser::RootTextContext* UserAgentParser::RootElementsContext::rootText() {
  return getRuleContext<UserAgentParser::RootTextContext>(0);
}


size_t UserAgentParser::RootElementsContext::getRuleIndex() const {
  return UserAgentParser::RuleRootElements;
}

void UserAgentParser::RootElementsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRootElements(this);
}

void UserAgentParser::RootElementsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRootElements(this);
}


std::any UserAgentParser::RootElementsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<UserAgentVisitor*>(visitor))
    return parserVisitor->visitRootElements(this);
  else
    return visitor->visitChildren(this);
}

UserAgentParser::RootElementsContext* UserAgentParser::rootElements() {
  RootElementsContext *_localctx = _tracker.createInstance<RootElementsContext>(_ctx, getState());
  enterRule(_localctx, 2, UserAgentParser::RuleRootElements);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(97);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 5, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(92);
      keyValue();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(93);
      siteUrl();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(94);
      emailAddress();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(95);
      uuId();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(96);
      rootText();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RootTextContext ------------------------------------------------------------------

UserAgentParser::RootTextContext::RootTextContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* UserAgentParser::RootTextContext::VERSION() {
  return getToken(UserAgentParser::VERSION, 0);
}

std::vector<tree::TerminalNode *> UserAgentParser::RootTextContext::WORD() {
  return getTokens(UserAgentParser::WORD);
}

tree::TerminalNode* UserAgentParser::RootTextContext::WORD(size_t i) {
  return getToken(UserAgentParser::WORD, i);
}

tree::TerminalNode* UserAgentParser::RootTextContext::GIBBERISH() {
  return getToken(UserAgentParser::GIBBERISH, 0);
}

tree::TerminalNode* UserAgentParser::RootTextContext::MINUS() {
  return getToken(UserAgentParser::MINUS, 0);
}


size_t UserAgentParser::RootTextContext::getRuleIndex() const {
  return UserAgentParser::RuleRootText;
}

void UserAgentParser::RootTextContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRootText(this);
}

void UserAgentParser::RootTextContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRootText(this);
}


std::any UserAgentParser::RootTextContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<UserAgentVisitor*>(visitor))
    return parserVisitor->visitRootText(this);
  else
    return visitor->visitChildren(this);
}

UserAgentParser::RootTextContext* UserAgentParser::rootText() {
  RootTextContext *_localctx = _tracker.createInstance<RootTextContext>(_ctx, getState());
  enterRule(_localctx, 4, UserAgentParser::RuleRootText);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(107);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case UserAgentParser::VERSION: {
        enterOuterAlt(_localctx, 1);
        setState(99);
        match(UserAgentParser::VERSION);
        break;
      }

      case UserAgentParser::WORD: {
        enterOuterAlt(_localctx, 2);
        setState(101); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(100);
                  match(UserAgentParser::WORD);
                  break;
                }

          default:
            throw NoViableAltException(this);
          }
          setState(103); 
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
        break;
      }

      case UserAgentParser::GIBBERISH: {
        enterOuterAlt(_localctx, 3);
        setState(105);
        match(UserAgentParser::GIBBERISH);
        break;
      }

      case UserAgentParser::MINUS: {
        enterOuterAlt(_localctx, 4);
        setState(106);
        match(UserAgentParser::MINUS);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProductContext ------------------------------------------------------------------

UserAgentParser::ProductContext::ProductContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

UserAgentParser::ProductNameContext* UserAgentParser::ProductContext::productName() {
  return getRuleContext<UserAgentParser::ProductNameContext>(0);
}

std::vector<UserAgentParser::ProductVersionContext *> UserAgentParser::ProductContext::productVersion() {
  return getRuleContexts<UserAgentParser::ProductVersionContext>();
}

UserAgentParser::ProductVersionContext* UserAgentParser::ProductContext::productVersion(size_t i) {
  return getRuleContext<UserAgentParser::ProductVersionContext>(i);
}

std::vector<UserAgentParser::CommentBlockContext *> UserAgentParser::ProductContext::commentBlock() {
  return getRuleContexts<UserAgentParser::CommentBlockContext>();
}

UserAgentParser::CommentBlockContext* UserAgentParser::ProductContext::commentBlock(size_t i) {
  return getRuleContext<UserAgentParser::CommentBlockContext>(i);
}

std::vector<tree::TerminalNode *> UserAgentParser::ProductContext::SLASH() {
  return getTokens(UserAgentParser::SLASH);
}

tree::TerminalNode* UserAgentParser::ProductContext::SLASH(size_t i) {
  return getToken(UserAgentParser::SLASH, i);
}

tree::TerminalNode* UserAgentParser::ProductContext::EOF() {
  return getToken(UserAgentParser::EOF, 0);
}

std::vector<tree::TerminalNode *> UserAgentParser::ProductContext::MINUS() {
  return getTokens(UserAgentParser::MINUS);
}

tree::TerminalNode* UserAgentParser::ProductContext::MINUS(size_t i) {
  return getToken(UserAgentParser::MINUS, i);
}

std::vector<tree::TerminalNode *> UserAgentParser::ProductContext::ATSIGN() {
  return getTokens(UserAgentParser::ATSIGN);
}

tree::TerminalNode* UserAgentParser::ProductContext::ATSIGN(size_t i) {
  return getToken(UserAgentParser::ATSIGN, i);
}

std::vector<UserAgentParser::ProductVersionWithCommasContext *> UserAgentParser::ProductContext::productVersionWithCommas() {
  return getRuleContexts<UserAgentParser::ProductVersionWithCommasContext>();
}

UserAgentParser::ProductVersionWithCommasContext* UserAgentParser::ProductContext::productVersionWithCommas(size_t i) {
  return getRuleContext<UserAgentParser::ProductVersionWithCommasContext>(i);
}

std::vector<UserAgentParser::ProductVersionSingleWordContext *> UserAgentParser::ProductContext::productVersionSingleWord() {
  return getRuleContexts<UserAgentParser::ProductVersionSingleWordContext>();
}

UserAgentParser::ProductVersionSingleWordContext* UserAgentParser::ProductContext::productVersionSingleWord(size_t i) {
  return getRuleContext<UserAgentParser::ProductVersionSingleWordContext>(i);
}

std::vector<tree::TerminalNode *> UserAgentParser::ProductContext::COLON() {
  return getTokens(UserAgentParser::COLON);
}

tree::TerminalNode* UserAgentParser::ProductContext::COLON(size_t i) {
  return getToken(UserAgentParser::COLON, i);
}

std::vector<tree::TerminalNode *> UserAgentParser::ProductContext::EQUALS() {
  return getTokens(UserAgentParser::EQUALS);
}

tree::TerminalNode* UserAgentParser::ProductContext::EQUALS(size_t i) {
  return getToken(UserAgentParser::EQUALS, i);
}

std::vector<tree::TerminalNode *> UserAgentParser::ProductContext::COMMA() {
  return getTokens(UserAgentParser::COMMA);
}

tree::TerminalNode* UserAgentParser::ProductContext::COMMA(size_t i) {
  return getToken(UserAgentParser::COMMA, i);
}

std::vector<tree::TerminalNode *> UserAgentParser::ProductContext::SEMICOLON() {
  return getTokens(UserAgentParser::SEMICOLON);
}

tree::TerminalNode* UserAgentParser::ProductContext::SEMICOLON(size_t i) {
  return getToken(UserAgentParser::SEMICOLON, i);
}

std::vector<UserAgentParser::ProductVersionWordsContext *> UserAgentParser::ProductContext::productVersionWords() {
  return getRuleContexts<UserAgentParser::ProductVersionWordsContext>();
}

UserAgentParser::ProductVersionWordsContext* UserAgentParser::ProductContext::productVersionWords(size_t i) {
  return getRuleContext<UserAgentParser::ProductVersionWordsContext>(i);
}


size_t UserAgentParser::ProductContext::getRuleIndex() const {
  return UserAgentParser::RuleProduct;
}

void UserAgentParser::ProductContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProduct(this);
}

void UserAgentParser::ProductContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProduct(this);
}


std::any UserAgentParser::ProductContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<UserAgentVisitor*>(visitor))
    return parserVisitor->visitProduct(this);
  else
    return visitor->visitChildren(this);
}

UserAgentParser::ProductContext* UserAgentParser::product() {
  ProductContext *_localctx = _tracker.createInstance<ProductContext>(_ctx, getState());
  enterRule(_localctx, 6, UserAgentParser::RuleProduct);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(327);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 61, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(109);
      productName();
      setState(111); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(110);
                productVersion();
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(113); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      setState(139);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(116);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == UserAgentParser::COLON) {
            setState(115);
            match(UserAgentParser::COLON);
          }
          setState(125);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case UserAgentParser::SLASH: {
              setState(119); 
              _errHandler->sync(this);
              _la = _input->LA(1);
              do {
                setState(118);
                match(UserAgentParser::SLASH);
                setState(121); 
                _errHandler->sync(this);
                _la = _input->LA(1);
              } while (_la == UserAgentParser::SLASH);
              break;
            }

            case UserAgentParser::MINUS: {
              setState(123);
              match(UserAgentParser::MINUS);
              break;
            }

            case UserAgentParser::ATSIGN: {
              setState(124);
              match(UserAgentParser::ATSIGN);
              break;
            }

          default:
            throw NoViableAltException(this);
          }
          setState(128);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == UserAgentParser::EQUALS) {
            setState(127);
            match(UserAgentParser::EQUALS);
          }
          setState(132);
          _errHandler->sync(this);
          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx)) {
          case 1: {
            setState(130);
            productVersionWithCommas();
            break;
          }

          case 2: {
            setState(131);
            productVersionSingleWord();
            break;
          }

          default:
            break;
          }
          setState(135);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx)) {
          case 1: {
            setState(134);
            match(UserAgentParser::COMMA);
            break;
          }

          default:
            break;
          } 
        }
        setState(141);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx);
      }
      setState(171);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(143);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == UserAgentParser::SLASH

          || _la == UserAgentParser::ATSIGN) {
            setState(142);
            _la = _input->LA(1);
            if (!(_la == UserAgentParser::SLASH

            || _la == UserAgentParser::ATSIGN)) {
            _errHandler->recoverInline(this);
            }
            else {
              _errHandler->reportMatch(this);
              consume();
            }
          }
          setState(146);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == UserAgentParser::SEMICOLON

          || _la == UserAgentParser::MINUS) {
            setState(145);
            _la = _input->LA(1);
            if (!(_la == UserAgentParser::SEMICOLON

            || _la == UserAgentParser::MINUS)) {
            _errHandler->recoverInline(this);
            }
            else {
              _errHandler->reportMatch(this);
              consume();
            }
          }
          setState(148);
          commentBlock();
          setState(166);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 22, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(150); 
              _errHandler->sync(this);
              _la = _input->LA(1);
              do {
                setState(149);
                _la = _input->LA(1);
                if (!(_la == UserAgentParser::SLASH

                || _la == UserAgentParser::ATSIGN)) {
                _errHandler->recoverInline(this);
                }
                else {
                  _errHandler->reportMatch(this);
                  consume();
                }
                setState(152); 
                _errHandler->sync(this);
                _la = _input->LA(1);
              } while (_la == UserAgentParser::SLASH

              || _la == UserAgentParser::ATSIGN);
              setState(155);
              _errHandler->sync(this);

              _la = _input->LA(1);
              if (_la == UserAgentParser::EQUALS) {
                setState(154);
                match(UserAgentParser::EQUALS);
              }
              setState(159);
              _errHandler->sync(this);
              switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 20, _ctx)) {
              case 1: {
                setState(157);
                productVersionWithCommas();
                break;
              }

              case 2: {
                setState(158);
                productVersionSingleWord();
                break;
              }

              default:
                break;
              }
              setState(162);
              _errHandler->sync(this);

              switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx)) {
              case 1: {
                setState(161);
                match(UserAgentParser::COMMA);
                break;
              }

              default:
                break;
              } 
            }
            setState(168);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 22, _ctx);
          } 
        }
        setState(173);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx);
      }
      setState(176);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == UserAgentParser::SLASH) {
        setState(174);
        match(UserAgentParser::SLASH);
        setState(175);
        match(UserAgentParser::EOF);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(178);
      productName();
      setState(206); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(180);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == UserAgentParser::SLASH

                || _la == UserAgentParser::ATSIGN) {
                  setState(179);
                  _la = _input->LA(1);
                  if (!(_la == UserAgentParser::SLASH

                  || _la == UserAgentParser::ATSIGN)) {
                  _errHandler->recoverInline(this);
                  }
                  else {
                    _errHandler->reportMatch(this);
                    consume();
                  }
                }
                setState(183);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == UserAgentParser::SEMICOLON

                || _la == UserAgentParser::MINUS) {
                  setState(182);
                  _la = _input->LA(1);
                  if (!(_la == UserAgentParser::SEMICOLON

                  || _la == UserAgentParser::MINUS)) {
                  _errHandler->recoverInline(this);
                  }
                  else {
                    _errHandler->reportMatch(this);
                    consume();
                  }
                }
                setState(185);
                commentBlock();
                setState(203);
                _errHandler->sync(this);
                alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx);
                while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
                  if (alt == 1) {
                    setState(187); 
                    _errHandler->sync(this);
                    _la = _input->LA(1);
                    do {
                      setState(186);
                      _la = _input->LA(1);
                      if (!(_la == UserAgentParser::SLASH

                      || _la == UserAgentParser::ATSIGN)) {
                      _errHandler->recoverInline(this);
                      }
                      else {
                        _errHandler->reportMatch(this);
                        consume();
                      }
                      setState(189); 
                      _errHandler->sync(this);
                      _la = _input->LA(1);
                    } while (_la == UserAgentParser::SLASH

                    || _la == UserAgentParser::ATSIGN);
                    setState(192);
                    _errHandler->sync(this);

                    _la = _input->LA(1);
                    if (_la == UserAgentParser::EQUALS) {
                      setState(191);
                      match(UserAgentParser::EQUALS);
                    }
                    setState(196);
                    _errHandler->sync(this);
                    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx)) {
                    case 1: {
                      setState(194);
                      productVersionWithCommas();
                      break;
                    }

                    case 2: {
                      setState(195);
                      productVersionSingleWord();
                      break;
                    }

                    default:
                      break;
                    }
                    setState(199);
                    _errHandler->sync(this);

                    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx)) {
                    case 1: {
                      setState(198);
                      match(UserAgentParser::COMMA);
                      break;
                    }

                    default:
                      break;
                    } 
                  }
                  setState(205);
                  _errHandler->sync(this);
                  alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx);
                }
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(208); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      setState(212);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == UserAgentParser::SLASH) {
        setState(210);
        match(UserAgentParser::SLASH);
        setState(211);
        match(UserAgentParser::EOF);
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(214);
      productName();
      setState(252); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(216);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == UserAgentParser::COLON) {
                  setState(215);
                  match(UserAgentParser::COLON);
                }
                setState(225);
                _errHandler->sync(this);
                switch (_input->LA(1)) {
                  case UserAgentParser::SLASH: {
                    setState(219); 
                    _errHandler->sync(this);
                    _la = _input->LA(1);
                    do {
                      setState(218);
                      match(UserAgentParser::SLASH);
                      setState(221); 
                      _errHandler->sync(this);
                      _la = _input->LA(1);
                    } while (_la == UserAgentParser::SLASH);
                    break;
                  }

                  case UserAgentParser::MINUS: {
                    setState(223);
                    match(UserAgentParser::MINUS);
                    break;
                  }

                  case UserAgentParser::ATSIGN: {
                    setState(224);
                    match(UserAgentParser::ATSIGN);
                    break;
                  }

                default:
                  throw NoViableAltException(this);
                }
                setState(227);
                productVersionWords();
                setState(240);
                _errHandler->sync(this);
                alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, _ctx);
                while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
                  if (alt == 1) {
                    setState(231);
                    _errHandler->sync(this);
                    _la = _input->LA(1);
                    while (_la == UserAgentParser::SLASH

                    || _la == UserAgentParser::ATSIGN) {
                      setState(228);
                      _la = _input->LA(1);
                      if (!(_la == UserAgentParser::SLASH

                      || _la == UserAgentParser::ATSIGN)) {
                      _errHandler->recoverInline(this);
                      }
                      else {
                        _errHandler->reportMatch(this);
                        consume();
                      }
                      setState(233);
                      _errHandler->sync(this);
                      _la = _input->LA(1);
                    }
                    setState(234);
                    productVersionWithCommas();
                    setState(236);
                    _errHandler->sync(this);

                    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 38, _ctx)) {
                    case 1: {
                      setState(235);
                      match(UserAgentParser::COMMA);
                      break;
                    }

                    default:
                      break;
                    } 
                  }
                  setState(242);
                  _errHandler->sync(this);
                  alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, _ctx);
                }
                setState(244);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, _ctx)) {
                case 1: {
                  setState(243);
                  _la = _input->LA(1);
                  if (!(_la == UserAgentParser::SLASH

                  || _la == UserAgentParser::ATSIGN)) {
                  _errHandler->recoverInline(this);
                  }
                  else {
                    _errHandler->reportMatch(this);
                    consume();
                  }
                  break;
                }

                default:
                  break;
                }
                setState(247);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 41, _ctx)) {
                case 1: {
                  setState(246);
                  _la = _input->LA(1);
                  if (!(_la == UserAgentParser::SEMICOLON

                  || _la == UserAgentParser::MINUS)) {
                  _errHandler->recoverInline(this);
                  }
                  else {
                    _errHandler->reportMatch(this);
                    consume();
                  }
                  break;
                }

                default:
                  break;
                }
                setState(250);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == UserAgentParser::BRACEOPEN

                || _la == UserAgentParser::BLOCKOPEN) {
                  setState(249);
                  commentBlock();
                }
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(254); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      setState(258);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == UserAgentParser::SLASH) {
        setState(256);
        match(UserAgentParser::SLASH);
        setState(257);
        match(UserAgentParser::EOF);
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(260);
      productName();
      setState(283); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(262);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == UserAgentParser::COLON) {
                  setState(261);
                  match(UserAgentParser::COLON);
                }
                setState(271);
                _errHandler->sync(this);
                switch (_input->LA(1)) {
                  case UserAgentParser::SLASH: {
                    setState(265); 
                    _errHandler->sync(this);
                    _la = _input->LA(1);
                    do {
                      setState(264);
                      match(UserAgentParser::SLASH);
                      setState(267); 
                      _errHandler->sync(this);
                      _la = _input->LA(1);
                    } while (_la == UserAgentParser::SLASH);
                    break;
                  }

                  case UserAgentParser::MINUS: {
                    setState(269);
                    match(UserAgentParser::MINUS);
                    break;
                  }

                  case UserAgentParser::ATSIGN: {
                    setState(270);
                    match(UserAgentParser::ATSIGN);
                    break;
                  }

                default:
                  throw NoViableAltException(this);
                }
                setState(274);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == UserAgentParser::EQUALS) {
                  setState(273);
                  match(UserAgentParser::EQUALS);
                }
                setState(278);
                _errHandler->sync(this);
                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx)) {
                case 1: {
                  setState(276);
                  productVersionWithCommas();
                  break;
                }

                case 2: {
                  setState(277);
                  productVersionSingleWord();
                  break;
                }

                default:
                  break;
                }
                setState(281);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 50, _ctx)) {
                case 1: {
                  setState(280);
                  match(UserAgentParser::COMMA);
                  break;
                }

                default:
                  break;
                }
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(285); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 51, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      setState(316);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(288);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == UserAgentParser::SLASH

          || _la == UserAgentParser::ATSIGN) {
            setState(287);
            _la = _input->LA(1);
            if (!(_la == UserAgentParser::SLASH

            || _la == UserAgentParser::ATSIGN)) {
            _errHandler->recoverInline(this);
            }
            else {
              _errHandler->reportMatch(this);
              consume();
            }
          }
          setState(291);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == UserAgentParser::SEMICOLON

          || _la == UserAgentParser::MINUS) {
            setState(290);
            _la = _input->LA(1);
            if (!(_la == UserAgentParser::SEMICOLON

            || _la == UserAgentParser::MINUS)) {
            _errHandler->recoverInline(this);
            }
            else {
              _errHandler->reportMatch(this);
              consume();
            }
          }
          setState(293);
          commentBlock();
          setState(311);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(295); 
              _errHandler->sync(this);
              _la = _input->LA(1);
              do {
                setState(294);
                _la = _input->LA(1);
                if (!(_la == UserAgentParser::SLASH

                || _la == UserAgentParser::ATSIGN)) {
                _errHandler->recoverInline(this);
                }
                else {
                  _errHandler->reportMatch(this);
                  consume();
                }
                setState(297); 
                _errHandler->sync(this);
                _la = _input->LA(1);
              } while (_la == UserAgentParser::SLASH

              || _la == UserAgentParser::ATSIGN);
              setState(300);
              _errHandler->sync(this);

              _la = _input->LA(1);
              if (_la == UserAgentParser::EQUALS) {
                setState(299);
                match(UserAgentParser::EQUALS);
              }
              setState(304);
              _errHandler->sync(this);
              switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 56, _ctx)) {
              case 1: {
                setState(302);
                productVersionWithCommas();
                break;
              }

              case 2: {
                setState(303);
                productVersionSingleWord();
                break;
              }

              default:
                break;
              }
              setState(307);
              _errHandler->sync(this);

              switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 57, _ctx)) {
              case 1: {
                setState(306);
                match(UserAgentParser::COMMA);
                break;
              }

              default:
                break;
              } 
            }
            setState(313);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx);
          } 
        }
        setState(318);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx);
      }
      setState(321);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == UserAgentParser::SLASH) {
        setState(319);
        match(UserAgentParser::SLASH);
        setState(320);
        match(UserAgentParser::EOF);
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(323);
      productName();

      setState(324);
      match(UserAgentParser::SLASH);
      setState(325);
      match(UserAgentParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CommentProductContext ------------------------------------------------------------------

UserAgentParser::CommentProductContext::CommentProductContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

UserAgentParser::ProductNameContext* UserAgentParser::CommentProductContext::productName() {
  return getRuleContext<UserAgentParser::ProductNameContext>(0);
}

std::vector<UserAgentParser::ProductVersionWithCommasContext *> UserAgentParser::CommentProductContext::productVersionWithCommas() {
  return getRuleContexts<UserAgentParser::ProductVersionWithCommasContext>();
}

UserAgentParser::ProductVersionWithCommasContext* UserAgentParser::CommentProductContext::productVersionWithCommas(size_t i) {
  return getRuleContext<UserAgentParser::ProductVersionWithCommasContext>(i);
}

std::vector<UserAgentParser::CommentBlockContext *> UserAgentParser::CommentProductContext::commentBlock() {
  return getRuleContexts<UserAgentParser::CommentBlockContext>();
}

UserAgentParser::CommentBlockContext* UserAgentParser::CommentProductContext::commentBlock(size_t i) {
  return getRuleContext<UserAgentParser::CommentBlockContext>(i);
}

std::vector<UserAgentParser::ProductVersionSingleWordContext *> UserAgentParser::CommentProductContext::productVersionSingleWord() {
  return getRuleContexts<UserAgentParser::ProductVersionSingleWordContext>();
}

UserAgentParser::ProductVersionSingleWordContext* UserAgentParser::CommentProductContext::productVersionSingleWord(size_t i) {
  return getRuleContext<UserAgentParser::ProductVersionSingleWordContext>(i);
}

std::vector<tree::TerminalNode *> UserAgentParser::CommentProductContext::EQUALS() {
  return getTokens(UserAgentParser::EQUALS);
}

tree::TerminalNode* UserAgentParser::CommentProductContext::EQUALS(size_t i) {
  return getToken(UserAgentParser::EQUALS, i);
}

std::vector<tree::TerminalNode *> UserAgentParser::CommentProductContext::COMMA() {
  return getTokens(UserAgentParser::COMMA);
}

tree::TerminalNode* UserAgentParser::CommentProductContext::COMMA(size_t i) {
  return getToken(UserAgentParser::COMMA, i);
}

std::vector<tree::TerminalNode *> UserAgentParser::CommentProductContext::MINUS() {
  return getTokens(UserAgentParser::MINUS);
}

tree::TerminalNode* UserAgentParser::CommentProductContext::MINUS(size_t i) {
  return getToken(UserAgentParser::MINUS, i);
}

std::vector<tree::TerminalNode *> UserAgentParser::CommentProductContext::SLASH() {
  return getTokens(UserAgentParser::SLASH);
}

tree::TerminalNode* UserAgentParser::CommentProductContext::SLASH(size_t i) {
  return getToken(UserAgentParser::SLASH, i);
}

std::vector<tree::TerminalNode *> UserAgentParser::CommentProductContext::ATSIGN() {
  return getTokens(UserAgentParser::ATSIGN);
}

tree::TerminalNode* UserAgentParser::CommentProductContext::ATSIGN(size_t i) {
  return getToken(UserAgentParser::ATSIGN, i);
}

std::vector<UserAgentParser::ProductVersionWordsContext *> UserAgentParser::CommentProductContext::productVersionWords() {
  return getRuleContexts<UserAgentParser::ProductVersionWordsContext>();
}

UserAgentParser::ProductVersionWordsContext* UserAgentParser::CommentProductContext::productVersionWords(size_t i) {
  return getRuleContext<UserAgentParser::ProductVersionWordsContext>(i);
}

std::vector<tree::TerminalNode *> UserAgentParser::CommentProductContext::COLON() {
  return getTokens(UserAgentParser::COLON);
}

tree::TerminalNode* UserAgentParser::CommentProductContext::COLON(size_t i) {
  return getToken(UserAgentParser::COLON, i);
}


size_t UserAgentParser::CommentProductContext::getRuleIndex() const {
  return UserAgentParser::RuleCommentProduct;
}

void UserAgentParser::CommentProductContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommentProduct(this);
}

void UserAgentParser::CommentProductContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommentProduct(this);
}


std::any UserAgentParser::CommentProductContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<UserAgentVisitor*>(visitor))
    return parserVisitor->visitCommentProduct(this);
  else
    return visitor->visitChildren(this);
}

UserAgentParser::CommentProductContext* UserAgentParser::commentProduct() {
  CommentProductContext *_localctx = _tracker.createInstance<CommentProductContext>(_ctx, getState());
  enterRule(_localctx, 8, UserAgentParser::RuleCommentProduct);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(531);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 110, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(329);
      productName();
      setState(331); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(330);
                productVersionWithCommas();
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(333); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 62, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      setState(352);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 67, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(336); 
          _errHandler->sync(this);
          _la = _input->LA(1);
          do {
            setState(335);
            _la = _input->LA(1);
            if (!(_la == UserAgentParser::SLASH

            || _la == UserAgentParser::ATSIGN)) {
            _errHandler->recoverInline(this);
            }
            else {
              _errHandler->reportMatch(this);
              consume();
            }
            setState(338); 
            _errHandler->sync(this);
            _la = _input->LA(1);
          } while (_la == UserAgentParser::SLASH

          || _la == UserAgentParser::ATSIGN);
          setState(341);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == UserAgentParser::EQUALS) {
            setState(340);
            match(UserAgentParser::EQUALS);
          }
          setState(345);
          _errHandler->sync(this);
          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 65, _ctx)) {
          case 1: {
            setState(343);
            productVersionWithCommas();
            break;
          }

          case 2: {
            setState(344);
            productVersionSingleWord();
            break;
          }

          default:
            break;
          }
          setState(348);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 66, _ctx)) {
          case 1: {
            setState(347);
            match(UserAgentParser::COMMA);
            break;
          }

          default:
            break;
          } 
        }
        setState(354);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 67, _ctx);
      }
      setState(384);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(356);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == UserAgentParser::SLASH

          || _la == UserAgentParser::ATSIGN) {
            setState(355);
            _la = _input->LA(1);
            if (!(_la == UserAgentParser::SLASH

            || _la == UserAgentParser::ATSIGN)) {
            _errHandler->recoverInline(this);
            }
            else {
              _errHandler->reportMatch(this);
              consume();
            }
          }
          setState(359);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == UserAgentParser::MINUS) {
            setState(358);
            match(UserAgentParser::MINUS);
          }
          setState(361);
          commentBlock();
          setState(379);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 74, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(363); 
              _errHandler->sync(this);
              _la = _input->LA(1);
              do {
                setState(362);
                _la = _input->LA(1);
                if (!(_la == UserAgentParser::SLASH

                || _la == UserAgentParser::ATSIGN)) {
                _errHandler->recoverInline(this);
                }
                else {
                  _errHandler->reportMatch(this);
                  consume();
                }
                setState(365); 
                _errHandler->sync(this);
                _la = _input->LA(1);
              } while (_la == UserAgentParser::SLASH

              || _la == UserAgentParser::ATSIGN);
              setState(368);
              _errHandler->sync(this);

              _la = _input->LA(1);
              if (_la == UserAgentParser::EQUALS) {
                setState(367);
                match(UserAgentParser::EQUALS);
              }
              setState(372);
              _errHandler->sync(this);
              switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 72, _ctx)) {
              case 1: {
                setState(370);
                productVersionWithCommas();
                break;
              }

              case 2: {
                setState(371);
                productVersionSingleWord();
                break;
              }

              default:
                break;
              }
              setState(375);
              _errHandler->sync(this);

              switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 73, _ctx)) {
              case 1: {
                setState(374);
                match(UserAgentParser::COMMA);
                break;
              }

              default:
                break;
              } 
            }
            setState(381);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 74, _ctx);
          } 
        }
        setState(386);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(387);
      productName();
      setState(415); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(389);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == UserAgentParser::SLASH

                || _la == UserAgentParser::ATSIGN) {
                  setState(388);
                  _la = _input->LA(1);
                  if (!(_la == UserAgentParser::SLASH

                  || _la == UserAgentParser::ATSIGN)) {
                  _errHandler->recoverInline(this);
                  }
                  else {
                    _errHandler->reportMatch(this);
                    consume();
                  }
                }
                setState(392);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == UserAgentParser::MINUS) {
                  setState(391);
                  match(UserAgentParser::MINUS);
                }
                setState(394);
                commentBlock();
                setState(412);
                _errHandler->sync(this);
                alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 82, _ctx);
                while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
                  if (alt == 1) {
                    setState(396); 
                    _errHandler->sync(this);
                    _la = _input->LA(1);
                    do {
                      setState(395);
                      _la = _input->LA(1);
                      if (!(_la == UserAgentParser::SLASH

                      || _la == UserAgentParser::ATSIGN)) {
                      _errHandler->recoverInline(this);
                      }
                      else {
                        _errHandler->reportMatch(this);
                        consume();
                      }
                      setState(398); 
                      _errHandler->sync(this);
                      _la = _input->LA(1);
                    } while (_la == UserAgentParser::SLASH

                    || _la == UserAgentParser::ATSIGN);
                    setState(401);
                    _errHandler->sync(this);

                    _la = _input->LA(1);
                    if (_la == UserAgentParser::EQUALS) {
                      setState(400);
                      match(UserAgentParser::EQUALS);
                    }
                    setState(405);
                    _errHandler->sync(this);
                    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 80, _ctx)) {
                    case 1: {
                      setState(403);
                      productVersionWithCommas();
                      break;
                    }

                    case 2: {
                      setState(404);
                      productVersionSingleWord();
                      break;
                    }

                    default:
                      break;
                    }
                    setState(408);
                    _errHandler->sync(this);

                    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 81, _ctx)) {
                    case 1: {
                      setState(407);
                      match(UserAgentParser::COMMA);
                      break;
                    }

                    default:
                      break;
                    } 
                  }
                  setState(414);
                  _errHandler->sync(this);
                  alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 82, _ctx);
                }
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(417); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 83, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(419);
      productName();
      setState(448); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(421);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == UserAgentParser::COLON) {
                  setState(420);
                  match(UserAgentParser::COLON);
                }
                setState(430);
                _errHandler->sync(this);
                switch (_input->LA(1)) {
                  case UserAgentParser::SLASH: {
                    setState(424); 
                    _errHandler->sync(this);
                    _la = _input->LA(1);
                    do {
                      setState(423);
                      match(UserAgentParser::SLASH);
                      setState(426); 
                      _errHandler->sync(this);
                      _la = _input->LA(1);
                    } while (_la == UserAgentParser::SLASH);
                    break;
                  }

                  case UserAgentParser::MINUS: {
                    setState(428);
                    match(UserAgentParser::MINUS);
                    break;
                  }

                  case UserAgentParser::ATSIGN: {
                    setState(429);
                    match(UserAgentParser::ATSIGN);
                    break;
                  }

                default:
                  throw NoViableAltException(this);
                }
                setState(432);
                productVersionWords();
                setState(445);
                _errHandler->sync(this);
                alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 89, _ctx);
                while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
                  if (alt == 1) {
                    setState(436);
                    _errHandler->sync(this);
                    _la = _input->LA(1);
                    while (_la == UserAgentParser::SLASH

                    || _la == UserAgentParser::ATSIGN) {
                      setState(433);
                      _la = _input->LA(1);
                      if (!(_la == UserAgentParser::SLASH

                      || _la == UserAgentParser::ATSIGN)) {
                      _errHandler->recoverInline(this);
                      }
                      else {
                        _errHandler->reportMatch(this);
                        consume();
                      }
                      setState(438);
                      _errHandler->sync(this);
                      _la = _input->LA(1);
                    }
                    setState(439);
                    productVersionWithCommas();
                    setState(441);
                    _errHandler->sync(this);

                    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 88, _ctx)) {
                    case 1: {
                      setState(440);
                      match(UserAgentParser::COMMA);
                      break;
                    }

                    default:
                      break;
                    } 
                  }
                  setState(447);
                  _errHandler->sync(this);
                  alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 89, _ctx);
                }
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(450); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 90, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      setState(478);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 97, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(453);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == UserAgentParser::MINUS) {
            setState(452);
            match(UserAgentParser::MINUS);
          }
          setState(455);
          commentBlock();
          setState(473);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == UserAgentParser::SLASH

          || _la == UserAgentParser::ATSIGN) {
            setState(457); 
            _errHandler->sync(this);
            _la = _input->LA(1);
            do {
              setState(456);
              _la = _input->LA(1);
              if (!(_la == UserAgentParser::SLASH

              || _la == UserAgentParser::ATSIGN)) {
              _errHandler->recoverInline(this);
              }
              else {
                _errHandler->reportMatch(this);
                consume();
              }
              setState(459); 
              _errHandler->sync(this);
              _la = _input->LA(1);
            } while (_la == UserAgentParser::SLASH

            || _la == UserAgentParser::ATSIGN);
            setState(462);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == UserAgentParser::EQUALS) {
              setState(461);
              match(UserAgentParser::EQUALS);
            }
            setState(466);
            _errHandler->sync(this);
            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 94, _ctx)) {
            case 1: {
              setState(464);
              productVersionWithCommas();
              break;
            }

            case 2: {
              setState(465);
              productVersionSingleWord();
              break;
            }

            default:
              break;
            }
            setState(469);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 95, _ctx)) {
            case 1: {
              setState(468);
              match(UserAgentParser::COMMA);
              break;
            }

            default:
              break;
            }
            setState(475);
            _errHandler->sync(this);
            _la = _input->LA(1);
          } 
        }
        setState(480);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 97, _ctx);
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(481);
      productName();
      setState(498); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(489);
                _errHandler->sync(this);
                switch (_input->LA(1)) {
                  case UserAgentParser::SLASH: {
                    setState(483); 
                    _errHandler->sync(this);
                    _la = _input->LA(1);
                    do {
                      setState(482);
                      match(UserAgentParser::SLASH);
                      setState(485); 
                      _errHandler->sync(this);
                      _la = _input->LA(1);
                    } while (_la == UserAgentParser::SLASH);
                    break;
                  }

                  case UserAgentParser::MINUS: {
                    setState(487);
                    match(UserAgentParser::MINUS);
                    break;
                  }

                  case UserAgentParser::ATSIGN: {
                    setState(488);
                    match(UserAgentParser::ATSIGN);
                    break;
                  }

                default:
                  throw NoViableAltException(this);
                }
                setState(492);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == UserAgentParser::EQUALS) {
                  setState(491);
                  match(UserAgentParser::EQUALS);
                }

                setState(494);
                productVersionWithCommas();
                setState(496);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 101, _ctx)) {
                case 1: {
                  setState(495);
                  match(UserAgentParser::COMMA);
                  break;
                }

                default:
                  break;
                }
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(500); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 102, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      setState(528);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 109, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(503);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == UserAgentParser::MINUS) {
            setState(502);
            match(UserAgentParser::MINUS);
          }
          setState(505);
          commentBlock();
          setState(523);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == UserAgentParser::SLASH

          || _la == UserAgentParser::ATSIGN) {
            setState(507); 
            _errHandler->sync(this);
            _la = _input->LA(1);
            do {
              setState(506);
              _la = _input->LA(1);
              if (!(_la == UserAgentParser::SLASH

              || _la == UserAgentParser::ATSIGN)) {
              _errHandler->recoverInline(this);
              }
              else {
                _errHandler->reportMatch(this);
                consume();
              }
              setState(509); 
              _errHandler->sync(this);
              _la = _input->LA(1);
            } while (_la == UserAgentParser::SLASH

            || _la == UserAgentParser::ATSIGN);
            setState(512);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == UserAgentParser::EQUALS) {
              setState(511);
              match(UserAgentParser::EQUALS);
            }
            setState(516);
            _errHandler->sync(this);
            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 106, _ctx)) {
            case 1: {
              setState(514);
              productVersionWithCommas();
              break;
            }

            case 2: {
              setState(515);
              productVersionSingleWord();
              break;
            }

            default:
              break;
            }
            setState(519);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 107, _ctx)) {
            case 1: {
              setState(518);
              match(UserAgentParser::COMMA);
              break;
            }

            default:
              break;
            }
            setState(525);
            _errHandler->sync(this);
            _la = _input->LA(1);
          } 
        }
        setState(530);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 109, _ctx);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProductVersionWordsContext ------------------------------------------------------------------

UserAgentParser::ProductVersionWordsContext::ProductVersionWordsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> UserAgentParser::ProductVersionWordsContext::WORD() {
  return getTokens(UserAgentParser::WORD);
}

tree::TerminalNode* UserAgentParser::ProductVersionWordsContext::WORD(size_t i) {
  return getToken(UserAgentParser::WORD, i);
}

std::vector<tree::TerminalNode *> UserAgentParser::ProductVersionWordsContext::MINUS() {
  return getTokens(UserAgentParser::MINUS);
}

tree::TerminalNode* UserAgentParser::ProductVersionWordsContext::MINUS(size_t i) {
  return getToken(UserAgentParser::MINUS, i);
}

tree::TerminalNode* UserAgentParser::ProductVersionWordsContext::UNASSIGNEDVARIABLE() {
  return getToken(UserAgentParser::UNASSIGNEDVARIABLE, 0);
}

tree::TerminalNode* UserAgentParser::ProductVersionWordsContext::SPECIALVERSIONWORDS() {
  return getToken(UserAgentParser::SPECIALVERSIONWORDS, 0);
}


size_t UserAgentParser::ProductVersionWordsContext::getRuleIndex() const {
  return UserAgentParser::RuleProductVersionWords;
}

void UserAgentParser::ProductVersionWordsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProductVersionWords(this);
}

void UserAgentParser::ProductVersionWordsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProductVersionWords(this);
}


std::any UserAgentParser::ProductVersionWordsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<UserAgentVisitor*>(visitor))
    return parserVisitor->visitProductVersionWords(this);
  else
    return visitor->visitChildren(this);
}

UserAgentParser::ProductVersionWordsContext* UserAgentParser::productVersionWords() {
  ProductVersionWordsContext *_localctx = _tracker.createInstance<ProductVersionWordsContext>(_ctx, getState());
  enterRule(_localctx, 10, UserAgentParser::RuleProductVersionWords);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(545);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case UserAgentParser::WORD: {
        enterOuterAlt(_localctx, 1);
        setState(533);
        match(UserAgentParser::WORD);
        setState(540);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 112, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(535);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == UserAgentParser::MINUS) {
              setState(534);
              match(UserAgentParser::MINUS);
            }
            setState(537);
            match(UserAgentParser::WORD); 
          }
          setState(542);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 112, _ctx);
        }
        break;
      }

      case UserAgentParser::UNASSIGNEDVARIABLE: {
        enterOuterAlt(_localctx, 2);
        setState(543);
        match(UserAgentParser::UNASSIGNEDVARIABLE);
        break;
      }

      case UserAgentParser::SPECIALVERSIONWORDS: {
        enterOuterAlt(_localctx, 3);
        setState(544);
        match(UserAgentParser::SPECIALVERSIONWORDS);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProductNameContext ------------------------------------------------------------------

UserAgentParser::ProductNameContext::ProductNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

UserAgentParser::ProductNameKeyValueContext* UserAgentParser::ProductNameContext::productNameKeyValue() {
  return getRuleContext<UserAgentParser::ProductNameKeyValueContext>(0);
}

UserAgentParser::ProductNameEmailContext* UserAgentParser::ProductNameContext::productNameEmail() {
  return getRuleContext<UserAgentParser::ProductNameEmailContext>(0);
}

UserAgentParser::ProductNameUrlContext* UserAgentParser::ProductNameContext::productNameUrl() {
  return getRuleContext<UserAgentParser::ProductNameUrlContext>(0);
}

UserAgentParser::ProductNameVersionContext* UserAgentParser::ProductNameContext::productNameVersion() {
  return getRuleContext<UserAgentParser::ProductNameVersionContext>(0);
}

UserAgentParser::ProductNameUuidContext* UserAgentParser::ProductNameContext::productNameUuid() {
  return getRuleContext<UserAgentParser::ProductNameUuidContext>(0);
}

UserAgentParser::ProductNameWordsContext* UserAgentParser::ProductNameContext::productNameWords() {
  return getRuleContext<UserAgentParser::ProductNameWordsContext>(0);
}


size_t UserAgentParser::ProductNameContext::getRuleIndex() const {
  return UserAgentParser::RuleProductName;
}

void UserAgentParser::ProductNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProductName(this);
}

void UserAgentParser::ProductNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProductName(this);
}


std::any UserAgentParser::ProductNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<UserAgentVisitor*>(visitor))
    return parserVisitor->visitProductName(this);
  else
    return visitor->visitChildren(this);
}

UserAgentParser::ProductNameContext* UserAgentParser::productName() {
  ProductNameContext *_localctx = _tracker.createInstance<ProductNameContext>(_ctx, getState());
  enterRule(_localctx, 12, UserAgentParser::RuleProductName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(553);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 114, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(547);
      productNameKeyValue();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(548);
      productNameEmail();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(549);
      productNameUrl();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(550);
      productNameVersion();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(551);
      productNameUuid();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(552);
      productNameWords();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProductNameWordsContext ------------------------------------------------------------------

UserAgentParser::ProductNameWordsContext::ProductNameWordsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> UserAgentParser::ProductNameWordsContext::WORD() {
  return getTokens(UserAgentParser::WORD);
}

tree::TerminalNode* UserAgentParser::ProductNameWordsContext::WORD(size_t i) {
  return getToken(UserAgentParser::WORD, i);
}

std::vector<tree::TerminalNode *> UserAgentParser::ProductNameWordsContext::MINUS() {
  return getTokens(UserAgentParser::MINUS);
}

tree::TerminalNode* UserAgentParser::ProductNameWordsContext::MINUS(size_t i) {
  return getToken(UserAgentParser::MINUS, i);
}

std::vector<tree::TerminalNode *> UserAgentParser::ProductNameWordsContext::COMMA() {
  return getTokens(UserAgentParser::COMMA);
}

tree::TerminalNode* UserAgentParser::ProductNameWordsContext::COMMA(size_t i) {
  return getToken(UserAgentParser::COMMA, i);
}

tree::TerminalNode* UserAgentParser::ProductNameWordsContext::CURLYBRACEOPEN() {
  return getToken(UserAgentParser::CURLYBRACEOPEN, 0);
}

tree::TerminalNode* UserAgentParser::ProductNameWordsContext::CURLYBRACECLOSE() {
  return getToken(UserAgentParser::CURLYBRACECLOSE, 0);
}


size_t UserAgentParser::ProductNameWordsContext::getRuleIndex() const {
  return UserAgentParser::RuleProductNameWords;
}

void UserAgentParser::ProductNameWordsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProductNameWords(this);
}

void UserAgentParser::ProductNameWordsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProductNameWords(this);
}


std::any UserAgentParser::ProductNameWordsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<UserAgentVisitor*>(visitor))
    return parserVisitor->visitProductNameWords(this);
  else
    return visitor->visitChildren(this);
}

UserAgentParser::ProductNameWordsContext* UserAgentParser::productNameWords() {
  ProductNameWordsContext *_localctx = _tracker.createInstance<ProductNameWordsContext>(_ctx, getState());
  enterRule(_localctx, 14, UserAgentParser::RuleProductNameWords);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(613);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 125, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(555);
      match(UserAgentParser::WORD);
      setState(565);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 116, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(559);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == UserAgentParser::COMMA

          || _la == UserAgentParser::MINUS) {
            setState(556);
            _la = _input->LA(1);
            if (!(_la == UserAgentParser::COMMA

            || _la == UserAgentParser::MINUS)) {
            _errHandler->recoverInline(this);
            }
            else {
              _errHandler->reportMatch(this);
              consume();
            }
            setState(561);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(562);
          match(UserAgentParser::WORD); 
        }
        setState(567);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 116, _ctx);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(581);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == UserAgentParser::WORD) {
        setState(568);
        match(UserAgentParser::WORD);
        setState(578);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 8608808960) != 0)) {
          setState(572);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == UserAgentParser::COMMA

          || _la == UserAgentParser::MINUS) {
            setState(569);
            _la = _input->LA(1);
            if (!(_la == UserAgentParser::COMMA

            || _la == UserAgentParser::MINUS)) {
            _errHandler->recoverInline(this);
            }
            else {
              _errHandler->reportMatch(this);
              consume();
            }
            setState(574);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(575);
          match(UserAgentParser::WORD);
          setState(580);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
      }
      setState(583);
      match(UserAgentParser::CURLYBRACEOPEN);
      setState(584);
      match(UserAgentParser::WORD);
      setState(594);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 8608808960) != 0)) {
        setState(588);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == UserAgentParser::COMMA

        || _la == UserAgentParser::MINUS) {
          setState(585);
          _la = _input->LA(1);
          if (!(_la == UserAgentParser::COMMA

          || _la == UserAgentParser::MINUS)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(590);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(591);
        match(UserAgentParser::WORD);
        setState(596);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(597);
      match(UserAgentParser::CURLYBRACECLOSE);
      setState(611);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 124, _ctx)) {
      case 1: {
        setState(598);
        match(UserAgentParser::WORD);
        setState(608);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 123, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(602);
            _errHandler->sync(this);
            _la = _input->LA(1);
            while (_la == UserAgentParser::COMMA

            || _la == UserAgentParser::MINUS) {
              setState(599);
              _la = _input->LA(1);
              if (!(_la == UserAgentParser::COMMA

              || _la == UserAgentParser::MINUS)) {
              _errHandler->recoverInline(this);
              }
              else {
                _errHandler->reportMatch(this);
                consume();
              }
              setState(604);
              _errHandler->sync(this);
              _la = _input->LA(1);
            }
            setState(605);
            match(UserAgentParser::WORD); 
          }
          setState(610);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 123, _ctx);
        }
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProductVersionContext ------------------------------------------------------------------

UserAgentParser::ProductVersionContext::ProductVersionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

UserAgentParser::KeyValueContext* UserAgentParser::ProductVersionContext::keyValue() {
  return getRuleContext<UserAgentParser::KeyValueContext>(0);
}

UserAgentParser::EmailAddressContext* UserAgentParser::ProductVersionContext::emailAddress() {
  return getRuleContext<UserAgentParser::EmailAddressContext>(0);
}

UserAgentParser::SiteUrlContext* UserAgentParser::ProductVersionContext::siteUrl() {
  return getRuleContext<UserAgentParser::SiteUrlContext>(0);
}

UserAgentParser::UuIdContext* UserAgentParser::ProductVersionContext::uuId() {
  return getRuleContext<UserAgentParser::UuIdContext>(0);
}

UserAgentParser::Base64Context* UserAgentParser::ProductVersionContext::base64() {
  return getRuleContext<UserAgentParser::Base64Context>(0);
}

UserAgentParser::SingleVersionContext* UserAgentParser::ProductVersionContext::singleVersion() {
  return getRuleContext<UserAgentParser::SingleVersionContext>(0);
}

tree::TerminalNode* UserAgentParser::ProductVersionContext::SPECIALVERSIONWORDS() {
  return getToken(UserAgentParser::SPECIALVERSIONWORDS, 0);
}


size_t UserAgentParser::ProductVersionContext::getRuleIndex() const {
  return UserAgentParser::RuleProductVersion;
}

void UserAgentParser::ProductVersionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProductVersion(this);
}

void UserAgentParser::ProductVersionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProductVersion(this);
}


std::any UserAgentParser::ProductVersionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<UserAgentVisitor*>(visitor))
    return parserVisitor->visitProductVersion(this);
  else
    return visitor->visitChildren(this);
}

UserAgentParser::ProductVersionContext* UserAgentParser::productVersion() {
  ProductVersionContext *_localctx = _tracker.createInstance<ProductVersionContext>(_ctx, getState());
  enterRule(_localctx, 16, UserAgentParser::RuleProductVersion);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(622);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 126, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(615);
      keyValue();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(616);
      emailAddress();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(617);
      siteUrl();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(618);
      uuId();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(619);
      base64();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(620);
      singleVersion();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(621);
      match(UserAgentParser::SPECIALVERSIONWORDS);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProductVersionWithCommasContext ------------------------------------------------------------------

UserAgentParser::ProductVersionWithCommasContext::ProductVersionWithCommasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<UserAgentParser::KeyValueContext *> UserAgentParser::ProductVersionWithCommasContext::keyValue() {
  return getRuleContexts<UserAgentParser::KeyValueContext>();
}

UserAgentParser::KeyValueContext* UserAgentParser::ProductVersionWithCommasContext::keyValue(size_t i) {
  return getRuleContext<UserAgentParser::KeyValueContext>(i);
}

UserAgentParser::EmailAddressContext* UserAgentParser::ProductVersionWithCommasContext::emailAddress() {
  return getRuleContext<UserAgentParser::EmailAddressContext>(0);
}

UserAgentParser::SiteUrlContext* UserAgentParser::ProductVersionWithCommasContext::siteUrl() {
  return getRuleContext<UserAgentParser::SiteUrlContext>(0);
}

UserAgentParser::UuIdContext* UserAgentParser::ProductVersionWithCommasContext::uuId() {
  return getRuleContext<UserAgentParser::UuIdContext>(0);
}

UserAgentParser::Base64Context* UserAgentParser::ProductVersionWithCommasContext::base64() {
  return getRuleContext<UserAgentParser::Base64Context>(0);
}

UserAgentParser::SingleVersionWithCommasContext* UserAgentParser::ProductVersionWithCommasContext::singleVersionWithCommas() {
  return getRuleContext<UserAgentParser::SingleVersionWithCommasContext>(0);
}

tree::TerminalNode* UserAgentParser::ProductVersionWithCommasContext::SPECIALVERSIONWORDS() {
  return getToken(UserAgentParser::SPECIALVERSIONWORDS, 0);
}

tree::TerminalNode* UserAgentParser::ProductVersionWithCommasContext::CURLYBRACEOPEN() {
  return getToken(UserAgentParser::CURLYBRACEOPEN, 0);
}

tree::TerminalNode* UserAgentParser::ProductVersionWithCommasContext::CURLYBRACECLOSE() {
  return getToken(UserAgentParser::CURLYBRACECLOSE, 0);
}

std::vector<tree::TerminalNode *> UserAgentParser::ProductVersionWithCommasContext::COMMA() {
  return getTokens(UserAgentParser::COMMA);
}

tree::TerminalNode* UserAgentParser::ProductVersionWithCommasContext::COMMA(size_t i) {
  return getToken(UserAgentParser::COMMA, i);
}


size_t UserAgentParser::ProductVersionWithCommasContext::getRuleIndex() const {
  return UserAgentParser::RuleProductVersionWithCommas;
}

void UserAgentParser::ProductVersionWithCommasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProductVersionWithCommas(this);
}

void UserAgentParser::ProductVersionWithCommasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProductVersionWithCommas(this);
}


std::any UserAgentParser::ProductVersionWithCommasContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<UserAgentVisitor*>(visitor))
    return parserVisitor->visitProductVersionWithCommas(this);
  else
    return visitor->visitChildren(this);
}

UserAgentParser::ProductVersionWithCommasContext* UserAgentParser::productVersionWithCommas() {
  ProductVersionWithCommasContext *_localctx = _tracker.createInstance<ProductVersionWithCommasContext>(_ctx, getState());
  enterRule(_localctx, 18, UserAgentParser::RuleProductVersionWithCommas);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(642);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 128, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(624);
      keyValue();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(625);
      emailAddress();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(626);
      siteUrl();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(627);
      uuId();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(628);
      base64();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(629);
      singleVersionWithCommas();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(630);
      match(UserAgentParser::SPECIALVERSIONWORDS);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(631);
      match(UserAgentParser::CURLYBRACEOPEN);
      setState(632);
      keyValue();
      setState(637);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == UserAgentParser::COMMA) {
        setState(633);
        match(UserAgentParser::COMMA);
        setState(634);
        keyValue();
        setState(639);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(640);
      match(UserAgentParser::CURLYBRACECLOSE);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProductVersionSingleWordContext ------------------------------------------------------------------

UserAgentParser::ProductVersionSingleWordContext::ProductVersionSingleWordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* UserAgentParser::ProductVersionSingleWordContext::WORD() {
  return getToken(UserAgentParser::WORD, 0);
}

tree::TerminalNode* UserAgentParser::ProductVersionSingleWordContext::CURLYBRACEOPEN() {
  return getToken(UserAgentParser::CURLYBRACEOPEN, 0);
}

tree::TerminalNode* UserAgentParser::ProductVersionSingleWordContext::CURLYBRACECLOSE() {
  return getToken(UserAgentParser::CURLYBRACECLOSE, 0);
}


size_t UserAgentParser::ProductVersionSingleWordContext::getRuleIndex() const {
  return UserAgentParser::RuleProductVersionSingleWord;
}

void UserAgentParser::ProductVersionSingleWordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProductVersionSingleWord(this);
}

void UserAgentParser::ProductVersionSingleWordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProductVersionSingleWord(this);
}


std::any UserAgentParser::ProductVersionSingleWordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<UserAgentVisitor*>(visitor))
    return parserVisitor->visitProductVersionSingleWord(this);
  else
    return visitor->visitChildren(this);
}

UserAgentParser::ProductVersionSingleWordContext* UserAgentParser::productVersionSingleWord() {
  ProductVersionSingleWordContext *_localctx = _tracker.createInstance<ProductVersionSingleWordContext>(_ctx, getState());
  enterRule(_localctx, 20, UserAgentParser::RuleProductVersionSingleWord);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(648);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case UserAgentParser::WORD: {
        enterOuterAlt(_localctx, 1);
        setState(644);
        match(UserAgentParser::WORD);
        break;
      }

      case UserAgentParser::CURLYBRACEOPEN: {
        enterOuterAlt(_localctx, 2);
        setState(645);
        match(UserAgentParser::CURLYBRACEOPEN);
        setState(646);
        match(UserAgentParser::WORD);
        setState(647);
        match(UserAgentParser::CURLYBRACECLOSE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SingleVersionContext ------------------------------------------------------------------

UserAgentParser::SingleVersionContext::SingleVersionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* UserAgentParser::SingleVersionContext::VERSION() {
  return getToken(UserAgentParser::VERSION, 0);
}


size_t UserAgentParser::SingleVersionContext::getRuleIndex() const {
  return UserAgentParser::RuleSingleVersion;
}

void UserAgentParser::SingleVersionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSingleVersion(this);
}

void UserAgentParser::SingleVersionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSingleVersion(this);
}


std::any UserAgentParser::SingleVersionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<UserAgentVisitor*>(visitor))
    return parserVisitor->visitSingleVersion(this);
  else
    return visitor->visitChildren(this);
}

UserAgentParser::SingleVersionContext* UserAgentParser::singleVersion() {
  SingleVersionContext *_localctx = _tracker.createInstance<SingleVersionContext>(_ctx, getState());
  enterRule(_localctx, 22, UserAgentParser::RuleSingleVersion);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(650);
    match(UserAgentParser::VERSION);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SingleVersionWithCommasContext ------------------------------------------------------------------

UserAgentParser::SingleVersionWithCommasContext::SingleVersionWithCommasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> UserAgentParser::SingleVersionWithCommasContext::VERSION() {
  return getTokens(UserAgentParser::VERSION);
}

tree::TerminalNode* UserAgentParser::SingleVersionWithCommasContext::VERSION(size_t i) {
  return getToken(UserAgentParser::VERSION, i);
}

std::vector<tree::TerminalNode *> UserAgentParser::SingleVersionWithCommasContext::COMMA() {
  return getTokens(UserAgentParser::COMMA);
}

tree::TerminalNode* UserAgentParser::SingleVersionWithCommasContext::COMMA(size_t i) {
  return getToken(UserAgentParser::COMMA, i);
}


size_t UserAgentParser::SingleVersionWithCommasContext::getRuleIndex() const {
  return UserAgentParser::RuleSingleVersionWithCommas;
}

void UserAgentParser::SingleVersionWithCommasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSingleVersionWithCommas(this);
}

void UserAgentParser::SingleVersionWithCommasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSingleVersionWithCommas(this);
}


std::any UserAgentParser::SingleVersionWithCommasContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<UserAgentVisitor*>(visitor))
    return parserVisitor->visitSingleVersionWithCommas(this);
  else
    return visitor->visitChildren(this);
}

UserAgentParser::SingleVersionWithCommasContext* UserAgentParser::singleVersionWithCommas() {
  SingleVersionWithCommasContext *_localctx = _tracker.createInstance<SingleVersionWithCommasContext>(_ctx, getState());
  enterRule(_localctx, 24, UserAgentParser::RuleSingleVersionWithCommas);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(652);
    match(UserAgentParser::VERSION);
    setState(657);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 130, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(653);
        match(UserAgentParser::COMMA);
        setState(654);
        match(UserAgentParser::VERSION); 
      }
      setState(659);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 130, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProductNameVersionContext ------------------------------------------------------------------

UserAgentParser::ProductNameVersionContext::ProductNameVersionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* UserAgentParser::ProductNameVersionContext::VERSION() {
  return getToken(UserAgentParser::VERSION, 0);
}

std::vector<tree::TerminalNode *> UserAgentParser::ProductNameVersionContext::WORD() {
  return getTokens(UserAgentParser::WORD);
}

tree::TerminalNode* UserAgentParser::ProductNameVersionContext::WORD(size_t i) {
  return getToken(UserAgentParser::WORD, i);
}

std::vector<tree::TerminalNode *> UserAgentParser::ProductNameVersionContext::MINUS() {
  return getTokens(UserAgentParser::MINUS);
}

tree::TerminalNode* UserAgentParser::ProductNameVersionContext::MINUS(size_t i) {
  return getToken(UserAgentParser::MINUS, i);
}


size_t UserAgentParser::ProductNameVersionContext::getRuleIndex() const {
  return UserAgentParser::RuleProductNameVersion;
}

void UserAgentParser::ProductNameVersionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProductNameVersion(this);
}

void UserAgentParser::ProductNameVersionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProductNameVersion(this);
}


std::any UserAgentParser::ProductNameVersionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<UserAgentVisitor*>(visitor))
    return parserVisitor->visitProductNameVersion(this);
  else
    return visitor->visitChildren(this);
}

UserAgentParser::ProductNameVersionContext* UserAgentParser::productNameVersion() {
  ProductNameVersionContext *_localctx = _tracker.createInstance<ProductNameVersionContext>(_ctx, getState());
  enterRule(_localctx, 26, UserAgentParser::RuleProductNameVersion);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(660);
    match(UserAgentParser::VERSION);
    setState(667);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 132, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(662);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == UserAgentParser::MINUS) {
          setState(661);
          match(UserAgentParser::MINUS);
        }
        setState(664);
        match(UserAgentParser::WORD); 
      }
      setState(669);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 132, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProductNameEmailContext ------------------------------------------------------------------

UserAgentParser::ProductNameEmailContext::ProductNameEmailContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

UserAgentParser::EmailAddressContext* UserAgentParser::ProductNameEmailContext::emailAddress() {
  return getRuleContext<UserAgentParser::EmailAddressContext>(0);
}


size_t UserAgentParser::ProductNameEmailContext::getRuleIndex() const {
  return UserAgentParser::RuleProductNameEmail;
}

void UserAgentParser::ProductNameEmailContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProductNameEmail(this);
}

void UserAgentParser::ProductNameEmailContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProductNameEmail(this);
}


std::any UserAgentParser::ProductNameEmailContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<UserAgentVisitor*>(visitor))
    return parserVisitor->visitProductNameEmail(this);
  else
    return visitor->visitChildren(this);
}

UserAgentParser::ProductNameEmailContext* UserAgentParser::productNameEmail() {
  ProductNameEmailContext *_localctx = _tracker.createInstance<ProductNameEmailContext>(_ctx, getState());
  enterRule(_localctx, 28, UserAgentParser::RuleProductNameEmail);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(670);
    emailAddress();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProductNameUrlContext ------------------------------------------------------------------

UserAgentParser::ProductNameUrlContext::ProductNameUrlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

UserAgentParser::SiteUrlContext* UserAgentParser::ProductNameUrlContext::siteUrl() {
  return getRuleContext<UserAgentParser::SiteUrlContext>(0);
}


size_t UserAgentParser::ProductNameUrlContext::getRuleIndex() const {
  return UserAgentParser::RuleProductNameUrl;
}

void UserAgentParser::ProductNameUrlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProductNameUrl(this);
}

void UserAgentParser::ProductNameUrlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProductNameUrl(this);
}


std::any UserAgentParser::ProductNameUrlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<UserAgentVisitor*>(visitor))
    return parserVisitor->visitProductNameUrl(this);
  else
    return visitor->visitChildren(this);
}

UserAgentParser::ProductNameUrlContext* UserAgentParser::productNameUrl() {
  ProductNameUrlContext *_localctx = _tracker.createInstance<ProductNameUrlContext>(_ctx, getState());
  enterRule(_localctx, 30, UserAgentParser::RuleProductNameUrl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(672);
    siteUrl();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProductNameUuidContext ------------------------------------------------------------------

UserAgentParser::ProductNameUuidContext::ProductNameUuidContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

UserAgentParser::UuIdContext* UserAgentParser::ProductNameUuidContext::uuId() {
  return getRuleContext<UserAgentParser::UuIdContext>(0);
}


size_t UserAgentParser::ProductNameUuidContext::getRuleIndex() const {
  return UserAgentParser::RuleProductNameUuid;
}

void UserAgentParser::ProductNameUuidContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProductNameUuid(this);
}

void UserAgentParser::ProductNameUuidContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProductNameUuid(this);
}


std::any UserAgentParser::ProductNameUuidContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<UserAgentVisitor*>(visitor))
    return parserVisitor->visitProductNameUuid(this);
  else
    return visitor->visitChildren(this);
}

UserAgentParser::ProductNameUuidContext* UserAgentParser::productNameUuid() {
  ProductNameUuidContext *_localctx = _tracker.createInstance<ProductNameUuidContext>(_ctx, getState());
  enterRule(_localctx, 32, UserAgentParser::RuleProductNameUuid);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(674);
    uuId();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UuIdContext ------------------------------------------------------------------

UserAgentParser::UuIdContext::UuIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* UserAgentParser::UuIdContext::UUID() {
  return getToken(UserAgentParser::UUID, 0);
}

tree::TerminalNode* UserAgentParser::UuIdContext::CURLYBRACEOPEN() {
  return getToken(UserAgentParser::CURLYBRACEOPEN, 0);
}

tree::TerminalNode* UserAgentParser::UuIdContext::CURLYBRACECLOSE() {
  return getToken(UserAgentParser::CURLYBRACECLOSE, 0);
}


size_t UserAgentParser::UuIdContext::getRuleIndex() const {
  return UserAgentParser::RuleUuId;
}

void UserAgentParser::UuIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUuId(this);
}

void UserAgentParser::UuIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUuId(this);
}


std::any UserAgentParser::UuIdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<UserAgentVisitor*>(visitor))
    return parserVisitor->visitUuId(this);
  else
    return visitor->visitChildren(this);
}

UserAgentParser::UuIdContext* UserAgentParser::uuId() {
  UuIdContext *_localctx = _tracker.createInstance<UuIdContext>(_ctx, getState());
  enterRule(_localctx, 34, UserAgentParser::RuleUuId);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(680);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case UserAgentParser::UUID: {
        enterOuterAlt(_localctx, 1);
        setState(676);
        antlrcpp::downCast<UuIdContext *>(_localctx)->uuid = match(UserAgentParser::UUID);
        break;
      }

      case UserAgentParser::CURLYBRACEOPEN: {
        enterOuterAlt(_localctx, 2);
        setState(677);
        match(UserAgentParser::CURLYBRACEOPEN);
        setState(678);
        antlrcpp::downCast<UuIdContext *>(_localctx)->uuid = match(UserAgentParser::UUID);
        setState(679);
        match(UserAgentParser::CURLYBRACECLOSE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EmailAddressContext ------------------------------------------------------------------

UserAgentParser::EmailAddressContext::EmailAddressContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* UserAgentParser::EmailAddressContext::EMAIL() {
  return getToken(UserAgentParser::EMAIL, 0);
}

tree::TerminalNode* UserAgentParser::EmailAddressContext::CURLYBRACEOPEN() {
  return getToken(UserAgentParser::CURLYBRACEOPEN, 0);
}

tree::TerminalNode* UserAgentParser::EmailAddressContext::CURLYBRACECLOSE() {
  return getToken(UserAgentParser::CURLYBRACECLOSE, 0);
}


size_t UserAgentParser::EmailAddressContext::getRuleIndex() const {
  return UserAgentParser::RuleEmailAddress;
}

void UserAgentParser::EmailAddressContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEmailAddress(this);
}

void UserAgentParser::EmailAddressContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEmailAddress(this);
}


std::any UserAgentParser::EmailAddressContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<UserAgentVisitor*>(visitor))
    return parserVisitor->visitEmailAddress(this);
  else
    return visitor->visitChildren(this);
}

UserAgentParser::EmailAddressContext* UserAgentParser::emailAddress() {
  EmailAddressContext *_localctx = _tracker.createInstance<EmailAddressContext>(_ctx, getState());
  enterRule(_localctx, 36, UserAgentParser::RuleEmailAddress);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(686);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case UserAgentParser::EMAIL: {
        enterOuterAlt(_localctx, 1);
        setState(682);
        antlrcpp::downCast<EmailAddressContext *>(_localctx)->email = match(UserAgentParser::EMAIL);
        break;
      }

      case UserAgentParser::CURLYBRACEOPEN: {
        enterOuterAlt(_localctx, 2);
        setState(683);
        match(UserAgentParser::CURLYBRACEOPEN);
        setState(684);
        antlrcpp::downCast<EmailAddressContext *>(_localctx)->email = match(UserAgentParser::EMAIL);
        setState(685);
        match(UserAgentParser::CURLYBRACECLOSE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SiteUrlContext ------------------------------------------------------------------

UserAgentParser::SiteUrlContext::SiteUrlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* UserAgentParser::SiteUrlContext::URL() {
  return getToken(UserAgentParser::URL, 0);
}

tree::TerminalNode* UserAgentParser::SiteUrlContext::CURLYBRACEOPEN() {
  return getToken(UserAgentParser::CURLYBRACEOPEN, 0);
}

tree::TerminalNode* UserAgentParser::SiteUrlContext::CURLYBRACECLOSE() {
  return getToken(UserAgentParser::CURLYBRACECLOSE, 0);
}


size_t UserAgentParser::SiteUrlContext::getRuleIndex() const {
  return UserAgentParser::RuleSiteUrl;
}

void UserAgentParser::SiteUrlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSiteUrl(this);
}

void UserAgentParser::SiteUrlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSiteUrl(this);
}


std::any UserAgentParser::SiteUrlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<UserAgentVisitor*>(visitor))
    return parserVisitor->visitSiteUrl(this);
  else
    return visitor->visitChildren(this);
}

UserAgentParser::SiteUrlContext* UserAgentParser::siteUrl() {
  SiteUrlContext *_localctx = _tracker.createInstance<SiteUrlContext>(_ctx, getState());
  enterRule(_localctx, 38, UserAgentParser::RuleSiteUrl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(692);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case UserAgentParser::URL: {
        enterOuterAlt(_localctx, 1);
        setState(688);
        antlrcpp::downCast<SiteUrlContext *>(_localctx)->url = match(UserAgentParser::URL);
        break;
      }

      case UserAgentParser::CURLYBRACEOPEN: {
        enterOuterAlt(_localctx, 2);
        setState(689);
        match(UserAgentParser::CURLYBRACEOPEN);
        setState(690);
        antlrcpp::downCast<SiteUrlContext *>(_localctx)->url = match(UserAgentParser::URL);
        setState(691);
        match(UserAgentParser::CURLYBRACECLOSE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Base64Context ------------------------------------------------------------------

UserAgentParser::Base64Context::Base64Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* UserAgentParser::Base64Context::BASE64() {
  return getToken(UserAgentParser::BASE64, 0);
}

tree::TerminalNode* UserAgentParser::Base64Context::CURLYBRACEOPEN() {
  return getToken(UserAgentParser::CURLYBRACEOPEN, 0);
}

tree::TerminalNode* UserAgentParser::Base64Context::CURLYBRACECLOSE() {
  return getToken(UserAgentParser::CURLYBRACECLOSE, 0);
}


size_t UserAgentParser::Base64Context::getRuleIndex() const {
  return UserAgentParser::RuleBase64;
}

void UserAgentParser::Base64Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBase64(this);
}

void UserAgentParser::Base64Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBase64(this);
}


std::any UserAgentParser::Base64Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<UserAgentVisitor*>(visitor))
    return parserVisitor->visitBase64(this);
  else
    return visitor->visitChildren(this);
}

UserAgentParser::Base64Context* UserAgentParser::base64() {
  Base64Context *_localctx = _tracker.createInstance<Base64Context>(_ctx, getState());
  enterRule(_localctx, 40, UserAgentParser::RuleBase64);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(698);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case UserAgentParser::BASE64: {
        enterOuterAlt(_localctx, 1);
        setState(694);
        antlrcpp::downCast<Base64Context *>(_localctx)->value = match(UserAgentParser::BASE64);
        break;
      }

      case UserAgentParser::CURLYBRACEOPEN: {
        enterOuterAlt(_localctx, 2);
        setState(695);
        match(UserAgentParser::CURLYBRACEOPEN);
        setState(696);
        antlrcpp::downCast<Base64Context *>(_localctx)->value = match(UserAgentParser::BASE64);
        setState(697);
        match(UserAgentParser::CURLYBRACECLOSE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CommentSeparatorContext ------------------------------------------------------------------

UserAgentParser::CommentSeparatorContext::CommentSeparatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* UserAgentParser::CommentSeparatorContext::SEMICOLON() {
  return getToken(UserAgentParser::SEMICOLON, 0);
}

tree::TerminalNode* UserAgentParser::CommentSeparatorContext::COMMA() {
  return getToken(UserAgentParser::COMMA, 0);
}


size_t UserAgentParser::CommentSeparatorContext::getRuleIndex() const {
  return UserAgentParser::RuleCommentSeparator;
}

void UserAgentParser::CommentSeparatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommentSeparator(this);
}

void UserAgentParser::CommentSeparatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommentSeparator(this);
}


std::any UserAgentParser::CommentSeparatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<UserAgentVisitor*>(visitor))
    return parserVisitor->visitCommentSeparator(this);
  else
    return visitor->visitChildren(this);
}

UserAgentParser::CommentSeparatorContext* UserAgentParser::commentSeparator() {
  CommentSeparatorContext *_localctx = _tracker.createInstance<CommentSeparatorContext>(_ctx, getState());
  enterRule(_localctx, 42, UserAgentParser::RuleCommentSeparator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(700);
    _la = _input->LA(1);
    if (!(_la == UserAgentParser::SEMICOLON

    || _la == UserAgentParser::COMMA)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CommentBlockContext ------------------------------------------------------------------

UserAgentParser::CommentBlockContext::CommentBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* UserAgentParser::CommentBlockContext::BRACEOPEN() {
  return getToken(UserAgentParser::BRACEOPEN, 0);
}

std::vector<UserAgentParser::CommentEntryContext *> UserAgentParser::CommentBlockContext::commentEntry() {
  return getRuleContexts<UserAgentParser::CommentEntryContext>();
}

UserAgentParser::CommentEntryContext* UserAgentParser::CommentBlockContext::commentEntry(size_t i) {
  return getRuleContext<UserAgentParser::CommentEntryContext>(i);
}

tree::TerminalNode* UserAgentParser::CommentBlockContext::BRACECLOSE() {
  return getToken(UserAgentParser::BRACECLOSE, 0);
}

tree::TerminalNode* UserAgentParser::CommentBlockContext::EOF() {
  return getToken(UserAgentParser::EOF, 0);
}

std::vector<UserAgentParser::CommentSeparatorContext *> UserAgentParser::CommentBlockContext::commentSeparator() {
  return getRuleContexts<UserAgentParser::CommentSeparatorContext>();
}

UserAgentParser::CommentSeparatorContext* UserAgentParser::CommentBlockContext::commentSeparator(size_t i) {
  return getRuleContext<UserAgentParser::CommentSeparatorContext>(i);
}

tree::TerminalNode* UserAgentParser::CommentBlockContext::BLOCKOPEN() {
  return getToken(UserAgentParser::BLOCKOPEN, 0);
}

tree::TerminalNode* UserAgentParser::CommentBlockContext::BLOCKCLOSE() {
  return getToken(UserAgentParser::BLOCKCLOSE, 0);
}


size_t UserAgentParser::CommentBlockContext::getRuleIndex() const {
  return UserAgentParser::RuleCommentBlock;
}

void UserAgentParser::CommentBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommentBlock(this);
}

void UserAgentParser::CommentBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommentBlock(this);
}


std::any UserAgentParser::CommentBlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<UserAgentVisitor*>(visitor))
    return parserVisitor->visitCommentBlock(this);
  else
    return visitor->visitChildren(this);
}

UserAgentParser::CommentBlockContext* UserAgentParser::commentBlock() {
  CommentBlockContext *_localctx = _tracker.createInstance<CommentBlockContext>(_ctx, getState());
  enterRule(_localctx, 44, UserAgentParser::RuleCommentBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(726);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case UserAgentParser::BRACEOPEN: {
        enterOuterAlt(_localctx, 1);
        setState(702);
        match(UserAgentParser::BRACEOPEN);
        setState(703);
        commentEntry();
        setState(709);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == UserAgentParser::SEMICOLON

        || _la == UserAgentParser::COMMA) {
          setState(704);
          commentSeparator();
          setState(705);
          commentEntry();
          setState(711);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(712);
        _la = _input->LA(1);
        if (!(_la == UserAgentParser::EOF

        || _la == UserAgentParser::BRACECLOSE)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case UserAgentParser::BLOCKOPEN: {
        enterOuterAlt(_localctx, 2);
        setState(714);
        match(UserAgentParser::BLOCKOPEN);
        setState(715);
        commentEntry();
        setState(721);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == UserAgentParser::SEMICOLON

        || _la == UserAgentParser::COMMA) {
          setState(716);
          commentSeparator();
          setState(717);
          commentEntry();
          setState(723);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(724);
        _la = _input->LA(1);
        if (!(_la == UserAgentParser::EOF

        || _la == UserAgentParser::BLOCKCLOSE)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CommentEntryContext ------------------------------------------------------------------

UserAgentParser::CommentEntryContext::CommentEntryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

UserAgentParser::EmptyWordContext* UserAgentParser::CommentEntryContext::emptyWord() {
  return getRuleContext<UserAgentParser::EmptyWordContext>(0);
}

std::vector<UserAgentParser::MultipleWordsContext *> UserAgentParser::CommentEntryContext::multipleWords() {
  return getRuleContexts<UserAgentParser::MultipleWordsContext>();
}

UserAgentParser::MultipleWordsContext* UserAgentParser::CommentEntryContext::multipleWords(size_t i) {
  return getRuleContext<UserAgentParser::MultipleWordsContext>(i);
}

UserAgentParser::ProductNameNoVersionContext* UserAgentParser::CommentEntryContext::productNameNoVersion() {
  return getRuleContext<UserAgentParser::ProductNameNoVersionContext>(0);
}

UserAgentParser::KeyWithoutValueContext* UserAgentParser::CommentEntryContext::keyWithoutValue() {
  return getRuleContext<UserAgentParser::KeyWithoutValueContext>(0);
}

std::vector<tree::TerminalNode *> UserAgentParser::CommentEntryContext::CURLYBRACEOPEN() {
  return getTokens(UserAgentParser::CURLYBRACEOPEN);
}

tree::TerminalNode* UserAgentParser::CommentEntryContext::CURLYBRACEOPEN(size_t i) {
  return getToken(UserAgentParser::CURLYBRACEOPEN, i);
}

std::vector<tree::TerminalNode *> UserAgentParser::CommentEntryContext::CURLYBRACECLOSE() {
  return getTokens(UserAgentParser::CURLYBRACECLOSE);
}

tree::TerminalNode* UserAgentParser::CommentEntryContext::CURLYBRACECLOSE(size_t i) {
  return getToken(UserAgentParser::CURLYBRACECLOSE, i);
}

std::vector<UserAgentParser::CommentProductContext *> UserAgentParser::CommentEntryContext::commentProduct() {
  return getRuleContexts<UserAgentParser::CommentProductContext>();
}

UserAgentParser::CommentProductContext* UserAgentParser::CommentEntryContext::commentProduct(size_t i) {
  return getRuleContext<UserAgentParser::CommentProductContext>(i);
}

std::vector<UserAgentParser::KeyValueContext *> UserAgentParser::CommentEntryContext::keyValue() {
  return getRuleContexts<UserAgentParser::KeyValueContext>();
}

UserAgentParser::KeyValueContext* UserAgentParser::CommentEntryContext::keyValue(size_t i) {
  return getRuleContext<UserAgentParser::KeyValueContext>(i);
}

std::vector<UserAgentParser::UuIdContext *> UserAgentParser::CommentEntryContext::uuId() {
  return getRuleContexts<UserAgentParser::UuIdContext>();
}

UserAgentParser::UuIdContext* UserAgentParser::CommentEntryContext::uuId(size_t i) {
  return getRuleContext<UserAgentParser::UuIdContext>(i);
}

std::vector<UserAgentParser::SiteUrlContext *> UserAgentParser::CommentEntryContext::siteUrl() {
  return getRuleContexts<UserAgentParser::SiteUrlContext>();
}

UserAgentParser::SiteUrlContext* UserAgentParser::CommentEntryContext::siteUrl(size_t i) {
  return getRuleContext<UserAgentParser::SiteUrlContext>(i);
}

std::vector<UserAgentParser::EmailAddressContext *> UserAgentParser::CommentEntryContext::emailAddress() {
  return getRuleContexts<UserAgentParser::EmailAddressContext>();
}

UserAgentParser::EmailAddressContext* UserAgentParser::CommentEntryContext::emailAddress(size_t i) {
  return getRuleContext<UserAgentParser::EmailAddressContext>(i);
}

std::vector<UserAgentParser::VersionWordsContext *> UserAgentParser::CommentEntryContext::versionWords() {
  return getRuleContexts<UserAgentParser::VersionWordsContext>();
}

UserAgentParser::VersionWordsContext* UserAgentParser::CommentEntryContext::versionWords(size_t i) {
  return getRuleContext<UserAgentParser::VersionWordsContext>(i);
}

std::vector<UserAgentParser::Base64Context *> UserAgentParser::CommentEntryContext::base64() {
  return getRuleContexts<UserAgentParser::Base64Context>();
}

UserAgentParser::Base64Context* UserAgentParser::CommentEntryContext::base64(size_t i) {
  return getRuleContext<UserAgentParser::Base64Context>(i);
}

std::vector<UserAgentParser::CommentBlockContext *> UserAgentParser::CommentEntryContext::commentBlock() {
  return getRuleContexts<UserAgentParser::CommentBlockContext>();
}

UserAgentParser::CommentBlockContext* UserAgentParser::CommentEntryContext::commentBlock(size_t i) {
  return getRuleContext<UserAgentParser::CommentBlockContext>(i);
}

std::vector<tree::TerminalNode *> UserAgentParser::CommentEntryContext::UNASSIGNEDVARIABLE() {
  return getTokens(UserAgentParser::UNASSIGNEDVARIABLE);
}

tree::TerminalNode* UserAgentParser::CommentEntryContext::UNASSIGNEDVARIABLE(size_t i) {
  return getToken(UserAgentParser::UNASSIGNEDVARIABLE, i);
}

std::vector<tree::TerminalNode *> UserAgentParser::CommentEntryContext::MINUS() {
  return getTokens(UserAgentParser::MINUS);
}

tree::TerminalNode* UserAgentParser::CommentEntryContext::MINUS(size_t i) {
  return getToken(UserAgentParser::MINUS, i);
}


size_t UserAgentParser::CommentEntryContext::getRuleIndex() const {
  return UserAgentParser::RuleCommentEntry;
}

void UserAgentParser::CommentEntryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommentEntry(this);
}

void UserAgentParser::CommentEntryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommentEntry(this);
}


std::any UserAgentParser::CommentEntryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<UserAgentVisitor*>(visitor))
    return parserVisitor->visitCommentEntry(this);
  else
    return visitor->visitChildren(this);
}

UserAgentParser::CommentEntryContext* UserAgentParser::commentEntry() {
  CommentEntryContext *_localctx = _tracker.createInstance<CommentEntryContext>(_ctx, getState());
  enterRule(_localctx, 46, UserAgentParser::RuleCommentEntry);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(813);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 146, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(728);
      emptyWord();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(783); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(732);
                _errHandler->sync(this);
                _la = _input->LA(1);
                while (_la == UserAgentParser::UNASSIGNEDVARIABLE) {
                  setState(729);
                  match(UserAgentParser::UNASSIGNEDVARIABLE);
                  setState(734);
                  _errHandler->sync(this);
                  _la = _input->LA(1);
                }
                setState(775);
                _errHandler->sync(this);
                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 141, _ctx)) {
                case 1: {
                  setState(735);
                  commentProduct();
                  break;
                }

                case 2: {
                  setState(736);
                  keyValue();
                  break;
                }

                case 3: {
                  setState(737);
                  uuId();
                  break;
                }

                case 4: {
                  setState(738);
                  siteUrl();
                  break;
                }

                case 5: {
                  setState(739);
                  emailAddress();
                  break;
                }

                case 6: {
                  setState(740);
                  versionWords();
                  break;
                }

                case 7: {
                  setState(741);
                  base64();
                  break;
                }

                case 8: {
                  setState(742);
                  match(UserAgentParser::CURLYBRACEOPEN);
                  setState(743);
                  commentProduct();
                  setState(744);
                  match(UserAgentParser::CURLYBRACECLOSE);
                  break;
                }

                case 9: {
                  setState(746);
                  match(UserAgentParser::CURLYBRACEOPEN);
                  setState(747);
                  keyValue();
                  setState(748);
                  match(UserAgentParser::CURLYBRACECLOSE);
                  break;
                }

                case 10: {
                  setState(750);
                  match(UserAgentParser::CURLYBRACEOPEN);
                  setState(751);
                  uuId();
                  setState(752);
                  match(UserAgentParser::CURLYBRACECLOSE);
                  break;
                }

                case 11: {
                  setState(754);
                  match(UserAgentParser::CURLYBRACEOPEN);
                  setState(755);
                  siteUrl();
                  setState(756);
                  match(UserAgentParser::CURLYBRACECLOSE);
                  break;
                }

                case 12: {
                  setState(758);
                  match(UserAgentParser::CURLYBRACEOPEN);
                  setState(759);
                  emailAddress();
                  setState(760);
                  match(UserAgentParser::CURLYBRACECLOSE);
                  break;
                }

                case 13: {
                  setState(762);
                  match(UserAgentParser::CURLYBRACEOPEN);
                  setState(763);
                  multipleWords();
                  setState(764);
                  match(UserAgentParser::CURLYBRACECLOSE);
                  break;
                }

                case 14: {
                  setState(766);
                  match(UserAgentParser::CURLYBRACEOPEN);
                  setState(767);
                  versionWords();
                  setState(768);
                  match(UserAgentParser::CURLYBRACECLOSE);
                  break;
                }

                case 15: {
                  setState(770);
                  match(UserAgentParser::CURLYBRACEOPEN);
                  setState(771);
                  base64();
                  setState(772);
                  match(UserAgentParser::CURLYBRACECLOSE);
                  break;
                }

                case 16: {
                  setState(774);
                  commentBlock();
                  break;
                }

                default:
                  break;
                }

                setState(780);
                _errHandler->sync(this);
                alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 142, _ctx);
                while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
                  if (alt == 1) {
                    setState(777);
                    match(UserAgentParser::MINUS); 
                  }
                  setState(782);
                  _errHandler->sync(this);
                  alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 142, _ctx);
                }
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(785); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 143, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      setState(798);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 144, _ctx)) {
      case 1: {
        setState(787);
        multipleWords();
        break;
      }

      case 2: {
        setState(788);
        productNameNoVersion();
        break;
      }

      case 3: {
        setState(789);
        keyWithoutValue();
        break;
      }

      case 4: {
        setState(790);
        match(UserAgentParser::CURLYBRACEOPEN);
        setState(791);
        productNameNoVersion();
        setState(792);
        match(UserAgentParser::CURLYBRACECLOSE);
        break;
      }

      case 5: {
        setState(794);
        match(UserAgentParser::CURLYBRACEOPEN);
        setState(795);
        keyWithoutValue();
        setState(796);
        match(UserAgentParser::CURLYBRACECLOSE);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(811);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 145, _ctx)) {
      case 1: {
        setState(800);
        multipleWords();
        break;
      }

      case 2: {
        setState(801);
        productNameNoVersion();
        break;
      }

      case 3: {
        setState(802);
        keyWithoutValue();
        break;
      }

      case 4: {
        setState(803);
        match(UserAgentParser::CURLYBRACEOPEN);
        setState(804);
        productNameNoVersion();
        setState(805);
        match(UserAgentParser::CURLYBRACECLOSE);
        break;
      }

      case 5: {
        setState(807);
        match(UserAgentParser::CURLYBRACEOPEN);
        setState(808);
        keyWithoutValue();
        setState(809);
        match(UserAgentParser::CURLYBRACECLOSE);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProductNameKeyValueContext ------------------------------------------------------------------

UserAgentParser::ProductNameKeyValueContext::ProductNameKeyValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

UserAgentParser::KeyNameContext* UserAgentParser::ProductNameKeyValueContext::keyName() {
  return getRuleContext<UserAgentParser::KeyNameContext>(0);
}

std::vector<UserAgentParser::UuIdContext *> UserAgentParser::ProductNameKeyValueContext::uuId() {
  return getRuleContexts<UserAgentParser::UuIdContext>();
}

UserAgentParser::UuIdContext* UserAgentParser::ProductNameKeyValueContext::uuId(size_t i) {
  return getRuleContext<UserAgentParser::UuIdContext>(i);
}

std::vector<UserAgentParser::SiteUrlContext *> UserAgentParser::ProductNameKeyValueContext::siteUrl() {
  return getRuleContexts<UserAgentParser::SiteUrlContext>();
}

UserAgentParser::SiteUrlContext* UserAgentParser::ProductNameKeyValueContext::siteUrl(size_t i) {
  return getRuleContext<UserAgentParser::SiteUrlContext>(i);
}

std::vector<UserAgentParser::EmailAddressContext *> UserAgentParser::ProductNameKeyValueContext::emailAddress() {
  return getRuleContexts<UserAgentParser::EmailAddressContext>();
}

UserAgentParser::EmailAddressContext* UserAgentParser::ProductNameKeyValueContext::emailAddress(size_t i) {
  return getRuleContext<UserAgentParser::EmailAddressContext>(i);
}

std::vector<UserAgentParser::MultipleWordsContext *> UserAgentParser::ProductNameKeyValueContext::multipleWords() {
  return getRuleContexts<UserAgentParser::MultipleWordsContext>();
}

UserAgentParser::MultipleWordsContext* UserAgentParser::ProductNameKeyValueContext::multipleWords(size_t i) {
  return getRuleContext<UserAgentParser::MultipleWordsContext>(i);
}

std::vector<UserAgentParser::Base64Context *> UserAgentParser::ProductNameKeyValueContext::base64() {
  return getRuleContexts<UserAgentParser::Base64Context>();
}

UserAgentParser::Base64Context* UserAgentParser::ProductNameKeyValueContext::base64(size_t i) {
  return getRuleContext<UserAgentParser::Base64Context>(i);
}

std::vector<UserAgentParser::KeyValueProductVersionNameContext *> UserAgentParser::ProductNameKeyValueContext::keyValueProductVersionName() {
  return getRuleContexts<UserAgentParser::KeyValueProductVersionNameContext>();
}

UserAgentParser::KeyValueProductVersionNameContext* UserAgentParser::ProductNameKeyValueContext::keyValueProductVersionName(size_t i) {
  return getRuleContext<UserAgentParser::KeyValueProductVersionNameContext>(i);
}

std::vector<tree::TerminalNode *> UserAgentParser::ProductNameKeyValueContext::COLON() {
  return getTokens(UserAgentParser::COLON);
}

tree::TerminalNode* UserAgentParser::ProductNameKeyValueContext::COLON(size_t i) {
  return getToken(UserAgentParser::COLON, i);
}

std::vector<tree::TerminalNode *> UserAgentParser::ProductNameKeyValueContext::EQUALS() {
  return getTokens(UserAgentParser::EQUALS);
}

tree::TerminalNode* UserAgentParser::ProductNameKeyValueContext::EQUALS(size_t i) {
  return getToken(UserAgentParser::EQUALS, i);
}


size_t UserAgentParser::ProductNameKeyValueContext::getRuleIndex() const {
  return UserAgentParser::RuleProductNameKeyValue;
}

void UserAgentParser::ProductNameKeyValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProductNameKeyValue(this);
}

void UserAgentParser::ProductNameKeyValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProductNameKeyValue(this);
}


std::any UserAgentParser::ProductNameKeyValueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<UserAgentVisitor*>(visitor))
    return parserVisitor->visitProductNameKeyValue(this);
  else
    return visitor->visitChildren(this);
}

UserAgentParser::ProductNameKeyValueContext* UserAgentParser::productNameKeyValue() {
  ProductNameKeyValueContext *_localctx = _tracker.createInstance<ProductNameKeyValueContext>(_ctx, getState());
  enterRule(_localctx, 48, UserAgentParser::RuleProductNameKeyValue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(815);
    antlrcpp::downCast<ProductNameKeyValueContext *>(_localctx)->key = keyName();
    setState(829); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(817); 
              _errHandler->sync(this);
              _la = _input->LA(1);
              do {
                setState(816);
                _la = _input->LA(1);
                if (!(_la == UserAgentParser::COLON

                || _la == UserAgentParser::EQUALS)) {
                _errHandler->recoverInline(this);
                }
                else {
                  _errHandler->reportMatch(this);
                  consume();
                }
                setState(819); 
                _errHandler->sync(this);
                _la = _input->LA(1);
              } while (_la == UserAgentParser::COLON

              || _la == UserAgentParser::EQUALS);
              setState(827);
              _errHandler->sync(this);
              switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 148, _ctx)) {
              case 1: {
                setState(821);
                uuId();
                break;
              }

              case 2: {
                setState(822);
                siteUrl();
                break;
              }

              case 3: {
                setState(823);
                emailAddress();
                break;
              }

              case 4: {
                setState(824);
                multipleWords();
                break;
              }

              case 5: {
                setState(825);
                base64();
                break;
              }

              case 6: {
                setState(826);
                keyValueProductVersionName();
                break;
              }

              default:
                break;
              }
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(831); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 149, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProductNameNoVersionContext ------------------------------------------------------------------

UserAgentParser::ProductNameNoVersionContext::ProductNameNoVersionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

UserAgentParser::ProductNameContext* UserAgentParser::ProductNameNoVersionContext::productName() {
  return getRuleContext<UserAgentParser::ProductNameContext>(0);
}

tree::TerminalNode* UserAgentParser::ProductNameNoVersionContext::SLASH() {
  return getToken(UserAgentParser::SLASH, 0);
}


size_t UserAgentParser::ProductNameNoVersionContext::getRuleIndex() const {
  return UserAgentParser::RuleProductNameNoVersion;
}

void UserAgentParser::ProductNameNoVersionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProductNameNoVersion(this);
}

void UserAgentParser::ProductNameNoVersionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProductNameNoVersion(this);
}


std::any UserAgentParser::ProductNameNoVersionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<UserAgentVisitor*>(visitor))
    return parserVisitor->visitProductNameNoVersion(this);
  else
    return visitor->visitChildren(this);
}

UserAgentParser::ProductNameNoVersionContext* UserAgentParser::productNameNoVersion() {
  ProductNameNoVersionContext *_localctx = _tracker.createInstance<ProductNameNoVersionContext>(_ctx, getState());
  enterRule(_localctx, 50, UserAgentParser::RuleProductNameNoVersion);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(833);
    productName();
    setState(834);
    match(UserAgentParser::SLASH);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyValueProductVersionNameContext ------------------------------------------------------------------

UserAgentParser::KeyValueProductVersionNameContext::KeyValueProductVersionNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* UserAgentParser::KeyValueProductVersionNameContext::VERSION() {
  return getToken(UserAgentParser::VERSION, 0);
}

std::vector<tree::TerminalNode *> UserAgentParser::KeyValueProductVersionNameContext::SLASH() {
  return getTokens(UserAgentParser::SLASH);
}

tree::TerminalNode* UserAgentParser::KeyValueProductVersionNameContext::SLASH(size_t i) {
  return getToken(UserAgentParser::SLASH, i);
}

std::vector<tree::TerminalNode *> UserAgentParser::KeyValueProductVersionNameContext::WORD() {
  return getTokens(UserAgentParser::WORD);
}

tree::TerminalNode* UserAgentParser::KeyValueProductVersionNameContext::WORD(size_t i) {
  return getToken(UserAgentParser::WORD, i);
}


size_t UserAgentParser::KeyValueProductVersionNameContext::getRuleIndex() const {
  return UserAgentParser::RuleKeyValueProductVersionName;
}

void UserAgentParser::KeyValueProductVersionNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyValueProductVersionName(this);
}

void UserAgentParser::KeyValueProductVersionNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyValueProductVersionName(this);
}


std::any UserAgentParser::KeyValueProductVersionNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<UserAgentVisitor*>(visitor))
    return parserVisitor->visitKeyValueProductVersionName(this);
  else
    return visitor->visitChildren(this);
}

UserAgentParser::KeyValueProductVersionNameContext* UserAgentParser::keyValueProductVersionName() {
  KeyValueProductVersionNameContext *_localctx = _tracker.createInstance<KeyValueProductVersionNameContext>(_ctx, getState());
  enterRule(_localctx, 52, UserAgentParser::RuleKeyValueProductVersionName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(845);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 151, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(836);
      match(UserAgentParser::VERSION);
      setState(841);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 150, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(837);
          match(UserAgentParser::SLASH);
          setState(838);
          match(UserAgentParser::WORD); 
        }
        setState(843);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 150, _ctx);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(844);
      match(UserAgentParser::VERSION);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyValueContext ------------------------------------------------------------------

UserAgentParser::KeyValueContext::KeyValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

UserAgentParser::KeyNameContext* UserAgentParser::KeyValueContext::keyName() {
  return getRuleContext<UserAgentParser::KeyNameContext>(0);
}

std::vector<tree::TerminalNode *> UserAgentParser::KeyValueContext::COLON() {
  return getTokens(UserAgentParser::COLON);
}

tree::TerminalNode* UserAgentParser::KeyValueContext::COLON(size_t i) {
  return getToken(UserAgentParser::COLON, i);
}

std::vector<tree::TerminalNode *> UserAgentParser::KeyValueContext::EQUALS() {
  return getTokens(UserAgentParser::EQUALS);
}

tree::TerminalNode* UserAgentParser::KeyValueContext::EQUALS(size_t i) {
  return getToken(UserAgentParser::EQUALS, i);
}

std::vector<tree::TerminalNode *> UserAgentParser::KeyValueContext::CURLYBRACEOPEN() {
  return getTokens(UserAgentParser::CURLYBRACEOPEN);
}

tree::TerminalNode* UserAgentParser::KeyValueContext::CURLYBRACEOPEN(size_t i) {
  return getToken(UserAgentParser::CURLYBRACEOPEN, i);
}

std::vector<tree::TerminalNode *> UserAgentParser::KeyValueContext::CURLYBRACECLOSE() {
  return getTokens(UserAgentParser::CURLYBRACECLOSE);
}

tree::TerminalNode* UserAgentParser::KeyValueContext::CURLYBRACECLOSE(size_t i) {
  return getToken(UserAgentParser::CURLYBRACECLOSE, i);
}

std::vector<UserAgentParser::UuIdContext *> UserAgentParser::KeyValueContext::uuId() {
  return getRuleContexts<UserAgentParser::UuIdContext>();
}

UserAgentParser::UuIdContext* UserAgentParser::KeyValueContext::uuId(size_t i) {
  return getRuleContext<UserAgentParser::UuIdContext>(i);
}

std::vector<UserAgentParser::SiteUrlContext *> UserAgentParser::KeyValueContext::siteUrl() {
  return getRuleContexts<UserAgentParser::SiteUrlContext>();
}

UserAgentParser::SiteUrlContext* UserAgentParser::KeyValueContext::siteUrl(size_t i) {
  return getRuleContext<UserAgentParser::SiteUrlContext>(i);
}

std::vector<UserAgentParser::EmailAddressContext *> UserAgentParser::KeyValueContext::emailAddress() {
  return getRuleContexts<UserAgentParser::EmailAddressContext>();
}

UserAgentParser::EmailAddressContext* UserAgentParser::KeyValueContext::emailAddress(size_t i) {
  return getRuleContext<UserAgentParser::EmailAddressContext>(i);
}

std::vector<UserAgentParser::MultipleWordsContext *> UserAgentParser::KeyValueContext::multipleWords() {
  return getRuleContexts<UserAgentParser::MultipleWordsContext>();
}

UserAgentParser::MultipleWordsContext* UserAgentParser::KeyValueContext::multipleWords(size_t i) {
  return getRuleContext<UserAgentParser::MultipleWordsContext>(i);
}

std::vector<UserAgentParser::Base64Context *> UserAgentParser::KeyValueContext::base64() {
  return getRuleContexts<UserAgentParser::Base64Context>();
}

UserAgentParser::Base64Context* UserAgentParser::KeyValueContext::base64(size_t i) {
  return getRuleContext<UserAgentParser::Base64Context>(i);
}

std::vector<UserAgentParser::KeyValueVersionNameContext *> UserAgentParser::KeyValueContext::keyValueVersionName() {
  return getRuleContexts<UserAgentParser::KeyValueVersionNameContext>();
}

UserAgentParser::KeyValueVersionNameContext* UserAgentParser::KeyValueContext::keyValueVersionName(size_t i) {
  return getRuleContext<UserAgentParser::KeyValueVersionNameContext>(i);
}


size_t UserAgentParser::KeyValueContext::getRuleIndex() const {
  return UserAgentParser::RuleKeyValue;
}

void UserAgentParser::KeyValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyValue(this);
}

void UserAgentParser::KeyValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyValue(this);
}


std::any UserAgentParser::KeyValueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<UserAgentVisitor*>(visitor))
    return parserVisitor->visitKeyValue(this);
  else
    return visitor->visitChildren(this);
}

UserAgentParser::KeyValueContext* UserAgentParser::keyValue() {
  KeyValueContext *_localctx = _tracker.createInstance<KeyValueContext>(_ctx, getState());
  enterRule(_localctx, 54, UserAgentParser::RuleKeyValue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(847);
    antlrcpp::downCast<KeyValueContext *>(_localctx)->key = keyName();
    setState(874); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(849); 
              _errHandler->sync(this);
              _la = _input->LA(1);
              do {
                setState(848);
                _la = _input->LA(1);
                if (!(_la == UserAgentParser::COLON

                || _la == UserAgentParser::EQUALS)) {
                _errHandler->recoverInline(this);
                }
                else {
                  _errHandler->reportMatch(this);
                  consume();
                }
                setState(851); 
                _errHandler->sync(this);
                _la = _input->LA(1);
              } while (_la == UserAgentParser::COLON

              || _la == UserAgentParser::EQUALS);
              setState(872);
              _errHandler->sync(this);
              switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 155, _ctx)) {
              case 1: {
                setState(853);
                match(UserAgentParser::CURLYBRACEOPEN);
                setState(860);
                _errHandler->sync(this);
                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 153, _ctx)) {
                case 1: {
                  setState(854);
                  uuId();
                  break;
                }

                case 2: {
                  setState(855);
                  siteUrl();
                  break;
                }

                case 3: {
                  setState(856);
                  emailAddress();
                  break;
                }

                case 4: {
                  setState(857);
                  multipleWords();
                  break;
                }

                case 5: {
                  setState(858);
                  base64();
                  break;
                }

                case 6: {
                  setState(859);
                  keyValueVersionName();
                  break;
                }

                default:
                  break;
                }
                setState(862);
                match(UserAgentParser::CURLYBRACECLOSE);
                break;
              }

              case 2: {
                setState(870);
                _errHandler->sync(this);
                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 154, _ctx)) {
                case 1: {
                  setState(864);
                  uuId();
                  break;
                }

                case 2: {
                  setState(865);
                  siteUrl();
                  break;
                }

                case 3: {
                  setState(866);
                  emailAddress();
                  break;
                }

                case 4: {
                  setState(867);
                  multipleWords();
                  break;
                }

                case 5: {
                  setState(868);
                  base64();
                  break;
                }

                case 6: {
                  setState(869);
                  keyValueVersionName();
                  break;
                }

                default:
                  break;
                }
                break;
              }

              default:
                break;
              }
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(876); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 156, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyWithoutValueContext ------------------------------------------------------------------

UserAgentParser::KeyWithoutValueContext::KeyWithoutValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

UserAgentParser::KeyNameContext* UserAgentParser::KeyWithoutValueContext::keyName() {
  return getRuleContext<UserAgentParser::KeyNameContext>(0);
}

std::vector<tree::TerminalNode *> UserAgentParser::KeyWithoutValueContext::COLON() {
  return getTokens(UserAgentParser::COLON);
}

tree::TerminalNode* UserAgentParser::KeyWithoutValueContext::COLON(size_t i) {
  return getToken(UserAgentParser::COLON, i);
}

std::vector<tree::TerminalNode *> UserAgentParser::KeyWithoutValueContext::EQUALS() {
  return getTokens(UserAgentParser::EQUALS);
}

tree::TerminalNode* UserAgentParser::KeyWithoutValueContext::EQUALS(size_t i) {
  return getToken(UserAgentParser::EQUALS, i);
}


size_t UserAgentParser::KeyWithoutValueContext::getRuleIndex() const {
  return UserAgentParser::RuleKeyWithoutValue;
}

void UserAgentParser::KeyWithoutValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyWithoutValue(this);
}

void UserAgentParser::KeyWithoutValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyWithoutValue(this);
}


std::any UserAgentParser::KeyWithoutValueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<UserAgentVisitor*>(visitor))
    return parserVisitor->visitKeyWithoutValue(this);
  else
    return visitor->visitChildren(this);
}

UserAgentParser::KeyWithoutValueContext* UserAgentParser::keyWithoutValue() {
  KeyWithoutValueContext *_localctx = _tracker.createInstance<KeyWithoutValueContext>(_ctx, getState());
  enterRule(_localctx, 56, UserAgentParser::RuleKeyWithoutValue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(878);
    antlrcpp::downCast<KeyWithoutValueContext *>(_localctx)->key = keyName();
    setState(880); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(879);
      _la = _input->LA(1);
      if (!(_la == UserAgentParser::COLON

      || _la == UserAgentParser::EQUALS)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(882); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == UserAgentParser::COLON

    || _la == UserAgentParser::EQUALS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyValueVersionNameContext ------------------------------------------------------------------

UserAgentParser::KeyValueVersionNameContext::KeyValueVersionNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* UserAgentParser::KeyValueVersionNameContext::VERSION() {
  return getToken(UserAgentParser::VERSION, 0);
}


size_t UserAgentParser::KeyValueVersionNameContext::getRuleIndex() const {
  return UserAgentParser::RuleKeyValueVersionName;
}

void UserAgentParser::KeyValueVersionNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyValueVersionName(this);
}

void UserAgentParser::KeyValueVersionNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyValueVersionName(this);
}


std::any UserAgentParser::KeyValueVersionNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<UserAgentVisitor*>(visitor))
    return parserVisitor->visitKeyValueVersionName(this);
  else
    return visitor->visitChildren(this);
}

UserAgentParser::KeyValueVersionNameContext* UserAgentParser::keyValueVersionName() {
  KeyValueVersionNameContext *_localctx = _tracker.createInstance<KeyValueVersionNameContext>(_ctx, getState());
  enterRule(_localctx, 58, UserAgentParser::RuleKeyValueVersionName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(884);
    match(UserAgentParser::VERSION);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyNameContext ------------------------------------------------------------------

UserAgentParser::KeyNameContext::KeyNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> UserAgentParser::KeyNameContext::WORD() {
  return getTokens(UserAgentParser::WORD);
}

tree::TerminalNode* UserAgentParser::KeyNameContext::WORD(size_t i) {
  return getToken(UserAgentParser::WORD, i);
}

std::vector<tree::TerminalNode *> UserAgentParser::KeyNameContext::MINUS() {
  return getTokens(UserAgentParser::MINUS);
}

tree::TerminalNode* UserAgentParser::KeyNameContext::MINUS(size_t i) {
  return getToken(UserAgentParser::MINUS, i);
}

tree::TerminalNode* UserAgentParser::KeyNameContext::VERSION() {
  return getToken(UserAgentParser::VERSION, 0);
}


size_t UserAgentParser::KeyNameContext::getRuleIndex() const {
  return UserAgentParser::RuleKeyName;
}

void UserAgentParser::KeyNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyName(this);
}

void UserAgentParser::KeyNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyName(this);
}


std::any UserAgentParser::KeyNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<UserAgentVisitor*>(visitor))
    return parserVisitor->visitKeyName(this);
  else
    return visitor->visitChildren(this);
}

UserAgentParser::KeyNameContext* UserAgentParser::keyName() {
  KeyNameContext *_localctx = _tracker.createInstance<KeyNameContext>(_ctx, getState());
  enterRule(_localctx, 60, UserAgentParser::RuleKeyName);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(895);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case UserAgentParser::WORD: {
        enterOuterAlt(_localctx, 1);
        setState(886);
        match(UserAgentParser::WORD);
        setState(891);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == UserAgentParser::MINUS) {
          setState(887);
          match(UserAgentParser::MINUS);
          setState(888);
          match(UserAgentParser::WORD);
          setState(893);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case UserAgentParser::VERSION: {
        enterOuterAlt(_localctx, 2);
        setState(894);
        match(UserAgentParser::VERSION);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EmptyWordContext ------------------------------------------------------------------

UserAgentParser::EmptyWordContext::EmptyWordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* UserAgentParser::EmptyWordContext::MINUS() {
  return getToken(UserAgentParser::MINUS, 0);
}


size_t UserAgentParser::EmptyWordContext::getRuleIndex() const {
  return UserAgentParser::RuleEmptyWord;
}

void UserAgentParser::EmptyWordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEmptyWord(this);
}

void UserAgentParser::EmptyWordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEmptyWord(this);
}


std::any UserAgentParser::EmptyWordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<UserAgentVisitor*>(visitor))
    return parserVisitor->visitEmptyWord(this);
  else
    return visitor->visitChildren(this);
}

UserAgentParser::EmptyWordContext* UserAgentParser::emptyWord() {
  EmptyWordContext *_localctx = _tracker.createInstance<EmptyWordContext>(_ctx, getState());
  enterRule(_localctx, 62, UserAgentParser::RuleEmptyWord);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(899);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case UserAgentParser::EOF:
      case UserAgentParser::BRACECLOSE:
      case UserAgentParser::BLOCKCLOSE:
      case UserAgentParser::SEMICOLON:
      case UserAgentParser::COMMA: {
        enterOuterAlt(_localctx, 1);

        break;
      }

      case UserAgentParser::MINUS: {
        enterOuterAlt(_localctx, 2);
        setState(898);
        match(UserAgentParser::MINUS);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MultipleWordsContext ------------------------------------------------------------------

UserAgentParser::MultipleWordsContext::MultipleWordsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> UserAgentParser::MultipleWordsContext::WORD() {
  return getTokens(UserAgentParser::WORD);
}

tree::TerminalNode* UserAgentParser::MultipleWordsContext::WORD(size_t i) {
  return getToken(UserAgentParser::WORD, i);
}

std::vector<tree::TerminalNode *> UserAgentParser::MultipleWordsContext::MINUS() {
  return getTokens(UserAgentParser::MINUS);
}

tree::TerminalNode* UserAgentParser::MultipleWordsContext::MINUS(size_t i) {
  return getToken(UserAgentParser::MINUS, i);
}

tree::TerminalNode* UserAgentParser::MultipleWordsContext::GIBBERISH() {
  return getToken(UserAgentParser::GIBBERISH, 0);
}

tree::TerminalNode* UserAgentParser::MultipleWordsContext::UNASSIGNEDVARIABLE() {
  return getToken(UserAgentParser::UNASSIGNEDVARIABLE, 0);
}


size_t UserAgentParser::MultipleWordsContext::getRuleIndex() const {
  return UserAgentParser::RuleMultipleWords;
}

void UserAgentParser::MultipleWordsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultipleWords(this);
}

void UserAgentParser::MultipleWordsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultipleWords(this);
}


std::any UserAgentParser::MultipleWordsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<UserAgentVisitor*>(visitor))
    return parserVisitor->visitMultipleWords(this);
  else
    return visitor->visitChildren(this);
}

UserAgentParser::MultipleWordsContext* UserAgentParser::multipleWords() {
  MultipleWordsContext *_localctx = _tracker.createInstance<MultipleWordsContext>(_ctx, getState());
  enterRule(_localctx, 64, UserAgentParser::RuleMultipleWords);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(933);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 166, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(908); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(904);
                _errHandler->sync(this);
                _la = _input->LA(1);
                while (_la == UserAgentParser::MINUS) {
                  setState(901);
                  match(UserAgentParser::MINUS);
                  setState(906);
                  _errHandler->sync(this);
                  _la = _input->LA(1);
                }
                setState(907);
                match(UserAgentParser::WORD);
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(910); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 162, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      setState(915);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 163, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(912);
          match(UserAgentParser::MINUS); 
        }
        setState(917);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 163, _ctx);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(921);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == UserAgentParser::WORD) {
        setState(918);
        match(UserAgentParser::WORD);
        setState(923);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(924);
      match(UserAgentParser::GIBBERISH);
      setState(928);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 165, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(925);
          match(UserAgentParser::WORD); 
        }
        setState(930);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 165, _ctx);
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(931);
      match(UserAgentParser::MINUS);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(932);
      match(UserAgentParser::UNASSIGNEDVARIABLE);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VersionWordsContext ------------------------------------------------------------------

UserAgentParser::VersionWordsContext::VersionWordsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> UserAgentParser::VersionWordsContext::VERSION() {
  return getTokens(UserAgentParser::VERSION);
}

tree::TerminalNode* UserAgentParser::VersionWordsContext::VERSION(size_t i) {
  return getToken(UserAgentParser::VERSION, i);
}

tree::TerminalNode* UserAgentParser::VersionWordsContext::SPECIALVERSIONWORDS() {
  return getToken(UserAgentParser::SPECIALVERSIONWORDS, 0);
}


size_t UserAgentParser::VersionWordsContext::getRuleIndex() const {
  return UserAgentParser::RuleVersionWords;
}

void UserAgentParser::VersionWordsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVersionWords(this);
}

void UserAgentParser::VersionWordsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<UserAgentListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVersionWords(this);
}


std::any UserAgentParser::VersionWordsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<UserAgentVisitor*>(visitor))
    return parserVisitor->visitVersionWords(this);
  else
    return visitor->visitChildren(this);
}

UserAgentParser::VersionWordsContext* UserAgentParser::versionWords() {
  VersionWordsContext *_localctx = _tracker.createInstance<VersionWordsContext>(_ctx, getState());
  enterRule(_localctx, 66, UserAgentParser::RuleVersionWords);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(941);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case UserAgentParser::VERSION: {
        enterOuterAlt(_localctx, 1);
        setState(936); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(935);
                  match(UserAgentParser::VERSION);
                  break;
                }

          default:
            throw NoViableAltException(this);
          }
          setState(938); 
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 167, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
        break;
      }

      case UserAgentParser::SPECIALVERSIONWORDS: {
        enterOuterAlt(_localctx, 2);
        setState(940);
        match(UserAgentParser::SPECIALVERSIONWORDS);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

void UserAgentParser::initialize() {
  ::antlr4::internal::call_once(useragentParserOnceFlag, useragentParserInitialize);
}
